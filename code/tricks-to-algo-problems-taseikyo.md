> @Date    : 2020-07-04 13:23:48
>
> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo

# 算法题常用技巧

## Table of Contents
- [数组](#数组)
- [链表](#链表)
- [树](#树)
- [位运算](#位运算)

## 数组

### 双指针

一前一后加快速度

### 位操作（异或）

比如找数组中重复的数

### 值做下标

比如给定数组的值为（0-n-1，n 为数组长度）那么可以把值当作下标来用。

### 定义二维数组

定义一个 rows x cols 数组

```c++
using V = vector<int>;
using VV = vector<V>;
VV mark(rows, V(cols, 0));
```

## 链表

### 快慢指针

一个走一步一个走两步，一可以判断环，二当快指针到链表尾，慢指针在中间

## 树

多用、善用递归

## 位运算

### 对于正整数，左移一位，就是将数值乘 2；右移一位就运算数值除 2；但是位操作的效率要比运算符高

`n <= 2 -> n *= 2`

### 一个数和另一个数异或两次得到的还是原来的数

- 不用临时变量交换两个整数

```c
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### `n & (n - 1)` 将整数 n 的最后一位为 1 的位变成 0

- 统计一个整数中二进制位上1的个数

```c
int fun(int num) {
	int count = 0;
	while (num) {
		num = num & (num - 1);
		++count;
	}
	return count；
}
```

- 判断一个数是不是 2 的幂

```c
// 返回 0 表示是 2 的幂，返回非 0 值表示不是 2 的幂
int fun(int num) {
    return n & (n - 1);
}
```

如果一个数是 2 的幂，则其有且只有一位为 1。因此，消除这一位后就会变成 0

- 判断一个 32 位整数是不是 4 的幂

```c
// 返回 0 表示不是 4 的幂，返回非 0 表示是 4 的幂
int fun(int num) {
    if(!(n & (n - 1))) {
        return (n & 0x55555555);
    }
    return 0;
}
```

是 4 的幂的数一定是 2 的幂，因此先判断是不是 2 的幂，2 的幂中 1 在奇数位上的是 4 的幂，与 0x55555555 按位与，如果在奇数位上有数则不为 0

- 输入两个整数 m 和 n，计算需要改变多少位能使 m 变成 n

```c
int fun(int m, int n) {
    // 将 m 和 n 按位异或，相同的位为 0，不同的位为 1
    m = m ^ n;
    int count = 0;
    //统计不同的位有多少个就ok
    while(m) {
        m = m & (m - 1);
        ++count;
    }
    return count；
}
```

### `n & (~n + 1)` 提取出整数 n 最后一位为 1 的数

n = 01101，`~n` 是将 n 按位取反就是 10010，`~n + 1` = 10011，最后，`n & (~n + 1)` = 00001

- 统计一个整数中二进制位上1的个数

```c
int fun(int num) {
    int count = 0;
    while(num) {
        n -= n & (~n + 1);
        ++count;
    }
    return count；
}
```

### 不使用 `+ - * /` 完成整数相加

```c
int Add(int num1, int num2) {
	int sum, carry;
	do {
		// 将两个数异或，模拟加法中相加不进位的结果
		sum = num1 ^ num2;
		// 只考虑进位的情况
		carry = (num1 & num2) << 1;
		num1 = sum;
		num2 = carry;
	} while (num2 != 0);
	// 将结果相加的过程就重复上述过程，直到进位为0
	return sum;
}
```

```
举例分析代码过程：
将12(二进制表示为0000 1100)与5(二进制表示为0000 0101)相加

第一次循环：
0000 1100 ^ 0000 0101 = 0000 1001
(0000 1100 & 0000 0101) << 1 = 0000 1000

第二次循环：
(0000 1001 ^ 0000 1000) = 0000 0001
(0000 1001 & 0000 1000) << 1 = 0001 0000

第三次循环：
(0000 0001 ^ 0001 0000) = 0001 0001
(0000 0001 & 0001 0000) << 1 = 0000 0000

循环结束
结果为0001 0001 = 17
```
