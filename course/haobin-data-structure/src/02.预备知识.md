# 预备知识

## Table of Contents
- [指针](#指针)
	- [指针的重要性](#指针的重要性)
	- [定义](#定义)
	- [指针和数组](#指针和数组)
- [结构体](#结构体)
	- [为什么会出现结构体](#为什么会出现结构体)
	- [什么叫做结构体](#什么叫做结构体)
	- [如何使用结构体](#如何使用结构体)
	- [注意事项](#注意事项)
	- [typedef 的使用](#typedef-的使用)
- [动态内存的分配和释放](#动态内存的分配和释放)
	- [跨函数使用内存的问题试题](#跨函数使用内存的问题试题)

## 指针

### 指针的重要性

指针是 C 语言的灵魂

### 定义

- 地址
	- 地址就是内存单元的编号
	- 从 0 开始的非负整数
	- 范围: 0 -- FFFFFFFF【0-4G-1】

- 指针
	- 指针就是地址，地址就是指针
	- 指针变量是存放内存单元地址的变量
	- 指针的本质是一个操作受限的非负整数

- 分类：
	1. 基本类型的指针
	2. 指针和数组的关系

- 内存
	- 内存是多字节组成的线性一维存储空间
	- 内存的基本划分单位是字节
	- 每个字节含有 8 位，每一位存放 1 个 0 或 1 个 1
	- 内存和编号是一一对应的

软件在运行前需要向操作系统申请存储空间。在软件运行期间，该软件所占空间不再分配给其他软件。当软件运行完毕后，操作系统将回收该内存空间（操作系统并不清空该内存空间中遗留下来的数据）。

- NOTE
	1. 指针变量也是变量，普通变量前不能加 \*，常量和表达式前不能加 &
	2. 局部变量只在本函数内部使用

- 如何通过被调函数修改主调函数中普通变量的值
	1. 实参为相关变量的地址
	2. 形参为以该变量的类型为类型的指针变量
	3. 在被调函数中通过 \* 形参变量名的形式   的形式就可以修改主函数

### 指针和数组

- 数组名
	- 一维数组名是个指针常量，它存放的是一维数组第一个元素的地址，它的值不能被改变，一维数组名指向的是数组的第一个元素。

- 下标和指针的关系
	- a[i] <==> \*(a+i)

- 指针变量的运算
	- 指针变量不能相加，不能相乘，不能相除
	- 如果两指针变量属于同一数组，则可以相减
	- 指针变量可以加减一整数，前提是最终结果不能超过指针变量

p+i 的值是 p+i\*(p 所指向的变量所占的字节数)

p-i 的值是 p-i\*(p 所指向的变量所占的字节数)

p++ <==> p+1   p-- <==> p-1

- 如何通过被调函数修改主调函数中一维数组的内容
	- 两个参数
		1. 数组首元素的指针变量
		2. 数组长度

无论指针指向的变量占多少个字节，指针变量统一都只占4个字节

## 结构体

### 为什么会出现结构体

为了表示一些复杂的数据，而普通的基本类型变量无法满足要求

### 什么叫做结构体

结构体是用户根据实际需要自己定义的复合数据类型

### 如何使用结构体

```c
// 定义结构体
struct Student {
    int sid;
    char name[200];
    int age;
};
```

两种方式（02.struct_2.c）：

1. 通过结构体变量名来实现（stu.sid）
2. 通过指向结构体变量的指针来实现（pstu->stu）

### 注意事项

- 结构体变量不能算术计算，但是可以赋值；
- 普通结构体变量和结构体指针变量作为函数传参的问题，推荐使用传递结构体指针的方式，这样效率高节约内存。（02.struct_3.c）

### typedef 的使用

```c
typedef int INT; // 相当于给int起了一个别名 INT
typedef struct Student {
 int sid;
 char name[100];
 char sex;
} *PSTU, STU; // STU -> struct Student  PSTU -> struct Student *
```


## 动态内存的分配和释放

动态分配一维数组：

```c
int *p = (int *)malloc(int len);
```

动态分配二维数组：

```c
int NC = 100, NR = 200;
int i, j;
char **a; // a[NR][NC] -- *a[NR] -- a[j][i]
a = (char **) malloc(sizeof(char *) * NR);
for (j = 0; j < NR; j++) {
	a[j] = (char *) malloc(sizeof(char) * NC);
}
```

### 跨函数使用内存的问题试题

下程序中，能够通过调用函数 fun，使 main 函数中的指针变量 p 指向一个合法的整型单元的是


```c
A) main()
  {  int *p;
     fun(p);
     … 
  } 
  int fun(int *p)
  { int s; 
    p=&s;
  }
B) main()
   { int *p;
     fun(&p);
     …
   }
  int fun(int **q)
  {  int s;
     *q=&s;
  }
C) #include <stdlib.h>
   main()
   {  int *p;
      fun(&p);
      …
   }
   int fun(int **q)
   {  *q=(int *)malloc(4);
   }
D) 
   #include <stdlib.h>
   main() 
  {  int  *p;
     fun(p);
     …
   }
   int fun(int *p)
   {  p=(int *)malloc(sizeof(int));
   }

                                              2003年4月45题
```

注释： 这个题很有意思。考查了：
1. 指针的指针的使用
2. 动态内存分配与自动变量的内存分配。

动态分配的内存必须调用 free() 函数才能释放，而自动变量一旦跳出它的代码作用范围，就会由编译器自动释放掉。
让我们先看：
1. A) 选项无论fun()中p的值如何变化，都不会影响到主函数中p的值，因为它是值传递 
2. B) 选项倒是把p的地址&p传递给了fun()函数，但遗憾的是，由于s是个自动变量，当推出fun()函数后，s变量所占内存单元会被会被释放掉，此时主函数中的p还是没法指向一个合法的int型单元 
3. C) 选项fun()的形参 int **p;表明p是个指向指针变量的指针变量，即是个指针的指针。 而主函数中的 int *p; 表明p只是个指针变量，但&p则指向了p，&p也是个指向指针变量p的指针变量，实参和形参类型一致。 fun()的功能是使实参p指向了一个int型变量， 又由于该int型变量是由malloc()动态分配的，所以推出fun()函数并不会影响实参p的指向， 故C是对 
4. D) 选项犯了和A同样的错误。 真想不到二C还会考到这个知识，哈哈!

