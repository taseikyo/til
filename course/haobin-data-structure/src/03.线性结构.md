> @Date    : 2020-06-19 17:51:40
>
> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo

# 线性结构

[readme](../README.md) | [previous](02.预备知识.md) | [next](04.非线性结构.md)

把所有的节点用一条直线穿起来

## Table of Contents
- [数组](#数组)
	- [什么叫数组](#什么叫数组)
	- [数组的优缺点](#数组的优缺点)
- [链表](#链表)
	- [定义](#定义)
	- [专业术语](#专业术语)
	- [确定一个链表需要几个参数](#确定一个链表需要几个参数)
	- [节点的定义](#节点的定义)
	- [链表的分类](#链表的分类)
	- [优缺点](#优缺点)
	- [算法](#算法)
- [栈](#栈)
	- [定义](#定义)
	- [分类](#分类)
	- [算法](#算法)
	- [应用](#应用)
- [队列](#队列)
	- [定义](#定义)
	- [分类](#分类)
	- [循环队列](#循环队列)
	- [算法](#算法)
	- [应用](#应用)
- [递归](#递归)
	- [定义](#定义)
	- [递归满足三个条件](#递归满足三个条件)
	- [循环和递归](#循环和递归)
	- [函数调用](#函数调用)
	- [应用](#应用)

## 数组

### 什么叫数组

元素类型相同，大小相等

### 数组的优缺点

- 优点：存取速度很快
- 缺点：事先需要知道数组的长度；插入删除元素很慢；空间通常有限制；需要大块连续的内存块

03.array.c 自行实现了一个数组的增删改查

## 链表

### 定义

n 个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点同时每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。

### 专业术语

- 首节点：存放第一个有效数据的节点
- 尾节点：存放最后一个有效数据的节点
- 头结点：位于首节点之前的一个节点，头结点并不存放有效的数据，加头结点的目的主要是为了方便对链表的操作
- 头指针：指向头结点的指针变量
- 尾指针：指向尾节点的指针变量

### 确定一个链表需要几个参数

只需要一个头指针参数，因为我们通过头指针可以推算出链表的其他所有信息

### 节点的定义

```c
typedef struct Node {
	int data; // 数据域
	struct Node * PNext; // 指针域
} NODE, *PNODE;//NODE等价于struct Node，PNODE等价于struct Node *
```

### 链表的分类

- 单链表：每一个节点只有一个指针域
- 双链表：每一个节点有两个指针域
- 循环链表：能通过任何一个节点找到其他所有的节点
- 非循环链表：不能通过任何一个节点找到其他所有的节点


### 优缺点

- 优点：空间没有限制，插入和删除元素很快
- 缺点：存取速度很慢

### 算法

- 遍历
- 查找
- 清空
- 销毁
- 求长度
- 排序
- 删除节点
- 插入节点

- 侠义的算法：与数据的存储方式密切相关
- 广义的算法：与数据的存储方式无关
- 泛型：利用某种技术达到的效果就是：不同的存储方式，执行的操作是一样的

## 栈

### 定义

一种可以实现“先进后出”的存储结构（03.stack.c）

### 分类

- 静态栈
- 动态栈

### 算法

- 压栈
- 出栈

### 应用

- 函数调用
- 中断
- 表达式求值
- 内存分配
- 缓冲处理
- 迷宫

## 队列

### 定义

一种可以实现“先进先出”的存储结构

### 分类

- 链式队列：用链表实现
- 静态队列：用数组实现，静态队列通常都必须是循环队列

### 循环队列

1. 静态队列为什么必须是循环队列
	- 如果要删除元素（出队），f只能加；如果要增加元素（入队），r只能加。（按照一般数组的方法）。r指向当前队列的下一个位置。 
2. 循环队列需要几个参数来确定
	- 两个：front 和 rear
	- 初始化：front = rear = 0
	- 非空：front 代表的是队列的第一个元素，rear 代表的是队列的最后一个有效元素的下一个元素
	- 空：front 和 rear 的值相等，但不一定是 0
3. 循环队列各个参数的含义
4. 循环队列入队伪算法讲解
	1. 将值存入 rear 所在的位置
	2. rear = (rear+1) % queue_length
5. 循环队列出队伪算法讲解
	- front = (front+1) % queue_length
6. 如何判断循环队列是否为空
	- front == rear
7. 如何判断循环队列是否已满
	- front 的值可能比 rear 相等/大/小
	- 两种方式
		1. 多加一个标识参数
		2. **少用一个元素**，(r+1) % queue_length == f => 满

### 算法

- 入队
- 出队

### 应用

所有和时间有关的操作都与队列有关

## 递归

### 定义

一个函数自己直接或间接调用自己

### 递归满足三个条件

- 递归必须得有一个明确的中止条件
- 该函数所处理的数据规模必须在递减
- 这个转化必须是可解的


### 循环和递归

- 递归
	- 易于理解
	- 速度慢
	- 存储空间大

- 循环
	- 不易理解
	- 速度快
	- 存储空间小

### 函数调用

- 当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事
	1. 将所有的实际参数、返回地址等信息传递给被调函数保存
	2. 为被调函数的局部变量（也包括形参）分配存储空间
	3. 将控制转移到被调函数的入口


- 从被调函数返回函数之前，系统也要完成三件事
	1. 保存被调函数的返回结果
	2. 释放被调函数所占的存储空间
	3. 依照被调函数保存的返回地址将控制转移到调用函数

- 当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储区，就做出栈操作，当前运行的函数永远都在栈顶位置。

- A 函数调用 A 函数和 A 函数调用 B 函数在计算机看来是没有任何区别的，只不过用我们日常的思维方式理解比较怪异而已！

- 不同函数直接相互调用

```c
#include <stdio.h>

void f();
void g();
void k();

void f() {
	printf("FFFF\n");
	g();
	printf("1111\n");
}

void g() {
	printf("GGGG\n");
	k();
	printf("2222\n");
}

void k() {
	printf("KKKK\n");
}

int main(void) {
	f();

	return 0;
}
```

- 自己调用自己

```c
#include <stdio.h>

void f(int n) {
	if (n == 1)
		printf("¹þ¹þ\n");
	else
		f(n - 1);
}

int main(void) {
	f(3);

	return 0;
}
```


### 应用

1. 1-100 求和

```c
int main(int argc, char const *argv[]) {
	int n = 100;
	printf("%d\n", sum(n));
	return 0;
}
​
int sum(int n) {
	if (1 == n)
		return 1;
	else
		return n + sum(n - 1);
}
```


2. 求阶乘

- 递归解法

```c
//假定n的值是1或大于1的值
long f(long n) {
	if (1 == n)
		return 1;
	else
		return f(n - 1) * n;

}

int main(int argc, char const *argv[]) {
	printf("%ld\n", f(100));

	return 0;
}
```

- 迭代解法

```c
int main(int argc, char const *argv[]) {
	int val;
	int i, mult = 1;

	printf("请输入一个数字: ");
	printf("val = ");
	scanf("%d", &val);

	for (i = 1; i <= val; ++i)
		mult = mult * i;

	printf("%d的阶乘是：%d\n", val, mult);


	return 0;
}
```

3. 汉诺塔

- 如果只有一个盘子
	- 直接将盘子从A柱子移到C柱子
- 否则
	- 先将A柱子上的n-1个盘子借助C柱子移到B柱子
	- 再直接将盘子从A柱子移到C柱子
	- 最后再将B柱子上的盘子借助A柱子移到C柱子上


```c
int main(int argc, char const *argv[]) {
	//柱子编号
	char ch1 = 'A';
	char ch2 = 'B';
	char ch3 = 'C';
	//盘子数量
	int n;
	printf("请输入盘子的数量");
	scanf("%d", &n);
	hanoi(n, 'A', 'B', 'C');

	return 0;
}
​
void hanoi(int n, char 'A', char 'B', char 'C') {
	if (1 == n)
		printf("编号为%d的盘子：%c-->%c\n", n, 'A', "C");
	else {
		hanoi(n - 1, A, C, B);
		printf("编号为%d的盘子：%c-->%c\n", n, 'A', "C");
		hanoi(n - 1, B, A, C);
	}
}
```

4. 走迷宫

直接深度优先遍历就完了，所以需要用栈来保存前面的路径。

[readme](../README.md) | [previous](02.预备知识.md) | [next](04.非线性结构.md)
