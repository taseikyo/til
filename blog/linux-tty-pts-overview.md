> @Date    : 2020-09-18 09:14:03
>
> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo


# Linux TTY/PTS 概述

> 原文：https://segmentfault.com/a/1190000009082089 作者：[public0821](https://segmentfault.com/u/public0821) 2017-04-16

## Table of Contents

- [TTY 历史](#tty-历史)
	- [支持多任务的计算机出现之前](#支持多任务的计算机出现之前)
	- [支持多任务的计算机出现之后](#支持多任务的计算机出现之后)
	- [内核 TTY 子系统](#内核-tty-子系统)
	- [TTY 设备](#tty-设备)
- [程序如何和 TTY 打交道](#程序如何和-tty-打交道)
- [TTY 是如何被创建的](#tty-是如何被创建的)
	- [键盘显示器直连（终端）](#键盘显示器直连（终端）)
	- [SSH 远程访问](#ssh-远程访问)
		- [建立连接](#建立连接)
		- [收发消息](#收发消息)
	- [键盘显示器直连（图形界面）](#键盘显示器直连（图形界面）)
	- [SSH + Screen/Tmux](#ssh--screentmux)
- [TTY 和 PTS 的区别](#tty-和-pts-的区别)
- [常见的 TTY 配置](#常见的-tty-配置)
- [TTY 相关信号](#tty-相关信号)
	- [SIGTTIN](#sigttin)
	- [SIGHUP](#sighup)
	- [SIGTSTP](#sigtstp)
- [结束语](#结束语)
- [参考](#参考)

当我们在键盘上敲下一个字母的时候，到底是怎么发送到相应的进程的呢？我们通过 ps、who 等命令看到的类似 tty1、pts/0 这样的输出，它们的作用和区别是什么呢？

## TTY 历史

### 支持多任务的计算机出现之前

在计算机出来以前，人们就已经在使用一种叫 teletype 的设备，用来相互之间传递信息，看起来像下面这样：

```
+----------+     Physical Line     +----------+
| teletype |<--------------------->| teletype |
+----------+                       +----------+
```

两个 teletype 之间用线连接起来，线两端可能也有类似于调制解调器之类的设备（这里将它们忽略），在一端的 teletype 上敲键盘时，相应的数据会发送到另一端的 teletype，具体功能是干什么的，我也不太了解。(我脑袋里面想到画面是在一端敲字，另一端打印出来)

> 这些都是老古董了，完全没接触过，所以只能简单的推测。

### 支持多任务的计算机出现之后

等到计算机支持多任务后，人们想到把这些 teletype 连到计算机上，作为计算机的终端，从而可以操作计算机。

使用 teletype 的主要原因有两个（个人见解）：

- 现实中已经存在了大量不同厂商的 teletype，可以充分利用现有资源
- teletype 的相关网络已经比较成熟，连起来方便

于是连接就发展成这样：

```
                                                                      +----------+ 
+----------+   +-------+     Physical Line     +-------+   +------+   |          |
| Terminal |<->| Modem |<--------------------->| Modem |<->| UART |<->| Computer |
+----------+   +-------+                       +-------+   +------+   |          |
                                                                      +----------+
```

- 左边的 Terminal 就是各种各样的 teletype
- 物理线路两边用上了 Modem，就是我们常说的 "猫"，那是因为后来网络已经慢慢的变发达了，大家可以共享连接了。（大概推测，可能不对）
- UART 可以理解为将 teletype 的信号转换成计算机能识别的信号的设备

### 内核 TTY 子系统

计算机为了支持这些 teletype，于是设计了名字叫做 TTY 的子系统，内部结构如下：

```
    +-----------------------------------------------+
    |                    Kernel                     |
    |                                 +--------+    |
    |   +--------+   +------------+   |        |    |       +----------------+
    |   |  UART  |   |    Line    |   |  TTY   |<---------->| User process A |
<------>|        |<->|            |<->|        |    |       +----------------+
    |   | driver |   | discipline |   | driver |<---------->| User process B |
    |   +--------+   +------------+   |        |    |       +----------------+
    |                                 +--------+    |
    |                                               |
    +-----------------------------------------------+
```

- UART driver 对接外面的 UART 设备
- Line discipline 主要是对输入和输出做一些处理，可以理解它是 TTY driver 的一部分
- TTY driver 用来处理各种终端设备
- 用户空间的进程通过 TTY driver 来和终端打交道

> 为了简单起见，后面的介绍中不再单独列出 UART driver 和 Line discipline，可以认为它们是 TTY driver 的一部分

### TTY 设备

对于每一个终端，TTY driver 都会创建一个 TTY 设备与它对应，如果有多个终端连接过来，那么看起来就是这个样子的：

```
                      +----------------+
                      |   TTY Driver   |
                      |                |
                      |   +-------+    |       +----------------+
 +------------+       |   |       |<---------->| User process A |
 | Terminal A |<--------->| ttyS0 |    |       +----------------+
 +------------+       |   |       |<---------->| User process B |
                      |   +-------+    |       +----------------+
                      |                |
                      |   +-------+    |       +----------------+
 +------------+       |   |       |<---------->| User process C |
 | Terminal B |<--------->| ttyS1 |    |       +----------------+
 +------------+       |   |       |<---------->| User process D |
                      |   +-------+    |       +----------------+
                      |                |
                      +----------------+
```

当驱动收到一个终端的连接时，就会根据终端的型号和参数创建相应的 tty 设备（上图中设备名称叫 ttyS0 是因为大部分终端的连接都是串行连接），由于每个终端可能都不一样，有自己的特殊命令和使用习惯，于是每个 tty 设备的配置可能都不一样。比如按 delete 键的时候，有些可能是要删前面的字符，而有些可能是删后面的，如果没配置对，就会导致某些按键不是自己想要的行为，这也是我们在使用模拟终端时，如果默认的配置跟我们的习惯不符，需要做一些个性化配置的原因。

后来随着计算机的不断发展，teletype 这些设备逐渐消失，我们不再需要专门的终端设备了，每个机器都有自己的键盘和显示器，每台机器都可以是其它机器的终端，远程的操作通过 ssh 来实现，但是内核 TTY 驱动这一架构没有发生变化，我们想要和系统中的进程进行 I/O 交互，还是需要通过 TTY 设备，于是出现了各种终端模拟软件，并且模拟的也是常见的几种终端，如 VT100、VT220、XTerm 等。

1.  可以通过命令 `toe -a` 列出系统支持的所有终端类型
2.  可以通过命令 infocmp 来比较两个终端的区别，比如 `infocmp vt100 vt220` 将会输出 vt100 和 vt220 的区别。

## 程序如何和 TTY 打交道

在讨论 TTY 设备是如何被创建及配置之前，我们先来看看 TTY 是如何被进程使用的：

```
#先用tty命令看看当前bash关联到了哪个tty
dev@debian:~$ tty
/dev/pts/1

#看tty都被哪些进程打开了
dev@debian:~$ lsof /dev/pts/1
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
bash     907  dev    0u   CHR  136,1      0t0    4 /dev/pts/1
bash     907  dev    1u   CHR  136,1      0t0    4 /dev/pts/1
bash     907  dev    2u   CHR  136,1      0t0    4 /dev/pts/1
bash     907  dev  255u   CHR  136,1      0t0    4 /dev/pts/1
lsof    1118  dev    0u   CHR  136,1      0t0    4 /dev/pts/1
lsof    1118  dev    1u   CHR  136,1      0t0    4 /dev/pts/1
lsof    1118  dev    2u   CHR  136,1      0t0    4 /dev/pts/1

#往tty里面直接写数据跟写标准输出是一样的效果
dev@dev:~$ echo hello > /dev/pts/2
hello
```

> pts 也是 tty 设备，它们的关系后面会介绍到

通过上面的 lsof 可以看出，当前运行的 bash 和 lsof 进程的 stdin(0u)、stdout(1u)、stderr(2u) 都绑定到了这个 TTY 上。

下面是 tty 和进程以及 I/O 设备交互的结构图：

```
   Input    +--------------------------+    R/W     +------+
----------->|                          |<---------->| bash |
            |          pts/1           |            +------+
<-----------|                          |<---------->| lsof |
   Output   | Foreground process group |    R/W     +------+
            +--------------------------+
```

- 可以把 tty 理解成一个管道（pipe），在一端写的内容可以从另一端读取出来，反之亦然。
- 这里 input 和 output 可以简单的理解为键盘和显示器，后面会介绍在各种情况下 input/ouput 都连接的什么东西。
- tty 里面有一个很重要的属性，叫 Foreground process group，记录了当前前端的进程组是哪一个。process group 的概念会在下一篇文章中介绍，这里可以简单的认为 process group 里面只有一个进程。
- 当 pts/1 收到 input 的输入后，会检查当前前端进程组是哪一个，然后将输入放到进程组的 leader 的输入缓存中，这样相应的 leader 进程就可以通过 read 函数得到用户的输入
- 当前端进程组里面的进程往 tty 设备上写数据时，tty 就会将数据输出到 output 设备上
- 当在 shell 中执行不同的命令时，前端进程组在不断的变化，而这种变化会由 shell 负责更新到 tty 设备中

从上面可以看出，进程和 tty 打交道很简单，只要保证后台进程不要读写 tty 就可以了，即写后台程序时，要将 stdin/stdout/stderr 重定向到其它地方（当然 deamon 程序还需要做很多其它处理）。

先抛出两个问题 (后面有答案)：

- 当非前端进程组里面的进程（后台进程）往 tty 设备上写数据时，会发生什么？会输出到 outpu 上吗？
- 当非前端进程组里面的进程（后台进程）从 tty 设备上读数据时，会发生什么？进程会阻塞吗？

## TTY 是如何被创建的

下面介绍几种常见的情况下 tty 设备是如何创建的，以及 input 和 output 设备都是啥。

### 键盘显示器直连（终端）

先看图再说话：

```
                   +-----------------------------------------+
                   |          Kernel                         |
                   |                           +--------+    |       +----------------+ 
 +----------+      |   +-------------------+   |  tty1  |<---------->| User processes |
 | Keyboard |--------->|                   |   +--------+    |       +----------------+
 +----------+      |   | Terminal Emulator |<->|  tty2  |<---------->| User processes |
 | Monitor  |<---------|                   |   +--------+    |       +----------------+
 +----------+      |   +-------------------+   |  tty3  |<---------->| User processes |
                   |                           +--------+    |       +----------------+
                   |                                         |
                   +-----------------------------------------+
```

键盘、显示器都和内核中的终端模拟器相连，由模拟器决定创建多少 tty，比如你在键盘上输入 ctrl+alt+F1 时，模拟器首先捕获到该输入，然后激活 tty1，这样键盘的输入会转发到 tty1，而 tty1 的输出会转发到显示器，同理用输入 ctrl+alt+F2，就会切换到 tty2。

当模拟器激活 tty 时如果发现没有进程与之关联，意味着这是第一次打开该 tty，于是会启动配置好的进程并和该 tty 绑定，一般该进程就是负责 login 的进程。

当切换到 tty2 后，tty1 里面的输出会输出到哪里呢？tty1 的输出还是会输出给模拟器，模拟器里会有每个 tty 的缓存，不过由于模拟器的缓存空间有限，所以下次切回 tty1 的时候，只能看到最新的输出，以前的输出已经不在了。

> 不确定这里的终端模拟器对应内核中具体的哪个模块，但肯定有这么个东西存在

### SSH 远程访问

```
 +----------+       +------------+
 | Keyboard |------>|            |
 +----------+       |  Terminal  |
 | Monitor  |<------|            |
 +----------+       +------------+
                          |
                          |  ssh protocol
                          |
                          ↓
                    +------------+
                    |            |
                    | ssh server |--------------------------+
                    |            |           fork           |
                    +------------+                          |
                        |   ↑                               |
                        |   |                               |
                  write |   | read                          |
                        |   |                               |
                  +-----|---|-------------------+           |
                  |     |   |                   |           ↓
                  |     ↓   |      +-------+    |       +-------+
                  |   +--------+   | pts/0 |<---------->| shell |
                  |   |        |   +-------+    |       +-------+
                  |   |  ptmx  |<->| pts/1 |<---------->| shell |
                  |   |        |   +-------+    |       +-------+
                  |   +--------+   | pts/2 |<---------->| shell |
                  |                +-------+    |       +-------+
                  |    Kernel                   |
                  +-----------------------------+
```

这里的 Terminal 可能是任何地方的程序，比如 windows 上的 putty，所以不讨论客户端的 Terminal 程序是怎么和键盘、显示器交互的。由于 Terminal 要和 ssh 服务器打交道，所以肯定要实现 ssh 的客户端功能。

这里将建立连接和收发数据分两条线路解释，为了描述简洁，这里以 sshd 代替 ssh 服务器程序：

#### 建立连接

1. Terminal 请求和 sshd 建立连接
2. 如果验证通过，sshd 将创建一个新的 session
3. 调用 API（posix_openpt()）请求 ptmx 创建一个 pts，创建成功后，sshd 将得到和 ptmx 关联的 fd，并将该 fd 和 session 关联起来。

```
#pty（pseudo terminal device）由两部分构成，ptmx是master端，pts是slave端，
#进程可以通过调用API请求ptmx创建一个pts，然后将会得到连接到ptmx的读写fd和一个新创建的pts，
#ptmx在内部会维护该fd和pts的对应关系，随后往这个fd的读写会被ptmx转发到对应的pts。

#这里可以看到sshd已经打开了/dev/ptmx
dev@debian:~$ sudo lsof /dev/ptmx
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    1191  dev    8u   CHR    5,2      0t0 6531 /dev/ptmx
sshd    1191  dev   10u   CHR    5,2      0t0 6531 /dev/ptmx
sshd    1191  dev   11u   CHR    5,2      0t0 6531 /dev/ptmx
```

4. 同时 sshd 创建 shell 进程，将新创建的 pts 和 shell 绑定

#### 收发消息

1. Terminal 收到键盘的输入，Terminal 通过 ssh 协议将数据发往 sshd
2. sshd 收到客户端的数据后，根据它自己管理的 session，找到该客户端对应的关联到 ptmx 上的 fd
3. 往找到的 fd 上写入客户端发过来的数据
4. ptmx 收到数据后，根据 fd 找到对应的 pts（该对应关系由 ptmx 自动维护），将数据包转发给对应的 pts
5. pts 收到数据包后，检查绑定到自己上面的当前前端进程组，将数据包发给该进程组的 leader
6. 由于 pts 上只有 shell，所以 shell 的 read 函数就收到了该数据包
7. shell 对收到的数据包进行处理，然后输出处理结果（也可能没有输出）
8. shell 通过 write 函数将结果写入 pts
9. pts 将结果转发给 ptmx
10. ptmx 根据 pts 找到对应的 fd，往该 fd 写入结果
11. sshd 收到该 fd 的结果后，找到对应的 session，然后将结果发给对应的客户端

### 键盘显示器直连（图形界面）

```
 +----------+       +------------+
 | Keyboard |------>|            |
 +----------+       |  Terminal  |--------------------------+
 | Monitor  |<------|            |           fork           |
 +----------+       +------------+                          |
                        |   ↑                               |
                        |   |                               |
                  write |   | read                          |
                        |   |                               |
                  +-----|---|-------------------+           |
                  |     |   |                   |           ↓
                  |     ↓   |      +-------+    |       +-------+
                  |   +--------+   | pts/0 |<---------->| shell |
                  |   |        |   +-------+    |       +-------+
                  |   |  ptmx  |<->| pts/1 |<---------->| shell |
                  |   |        |   +-------+    |       +-------+
                  |   +--------+   | pts/2 |<---------->| shell |
                  |                +-------+    |       +-------+
                  |    Kernel                   |
                  +-----------------------------+
```

> 为了简化起见，本篇不讨论 Linux 下图形界面里 Terminal 程序是怎么和键盘、显示器交互的。

这里和上面的不同点就是，这里的 Terminal 不需要实现 ssh 客户端，但需要把 ssh 服务器要干的活也干了（当然 ssh 通信相关的除外）。

### SSH + Screen/Tmux

常用 Linux 的同学应该对 screen 和 tmux 不陌生，通过它们启动的进程，就算网络断开了，也不会受到影响继续执行，下次连上去时还能看到进程的所有输出，还能继续接着干活。

这里以 tmux 为例介绍其原理：

```
 +----------+       +------------+
 | Keyboard |------>|            |
 +----------+       |  Terminal  |
 | Monitor  |<------|            |
 +----------+       +------------+
                          |
                          |  ssh protocol
                          |
                          ↓
                    +------------+
                    |            |
                    | ssh server |--------------------------+
                    |            |           fork           |
                    +------------+                          |
                        |   ↑                               |
                        |   |                               |
                  write |   | read                          |
                        |   |                               |
                  +-----|---|-------------------+           |
                  |     ↓   |                   |           ↓
                  |   +--------+   +-------+    |       +-------+  fork   +-------------+
                  |   |  ptmx  |<->| pts/0 |<---------->| shell |-------->| tmux client |
                  |   +--------+   +-------+    |       +-------+         +-------------+
                  |   |        |                |                               ↑
                  |   +--------+   +-------+    |       +-------+               |
                  |   |  ptmx  |<->| pts/2 |<---------->| shell |               |
                  |   +--------+   +-------+    |       +-------+               |
                  |     ↑   |  Kernel           |           ↑                   |
                  +-----|---|-------------------+           |                   |
                        |   |                               |                   |
                        |w/r|   +---------------------------+                   |
                        |   |   |            fork                               |
                        |   ↓   |                                               |
                    +-------------+                                             |
                    |             |                                             |
                    | tmux server |<--------------------------------------------+
                    |             |
                    +-------------+
```

> 系统中的 ptmx 只有一个，上图中画出来了两个，目的是为了表明 tmux 服务器和 sshd 都用 ptmx，但它们之间又互不干涉。

这种情况要稍微复杂一点，不过原理都是一样的，前半部分和普通 ssh 的方式是一样的，只是 pts/0 关联的前端进程不是 shell 了，而是变成了 tmux 客户端，所以 ssh 客户端发过来的数据包都会被 tmux 客户端收到，然后由 tmux 客户端转发给 tmux 服务器，而 tmux 服务器干的活和 ssh 的类似，也是维护一堆的 session，为每个 session 创建一个 pts，然后将 tmux 客户端发过来的数据转发给相应的 pts。

由于 tmux 服务器只和 tmux 客户端打交道，和 sshd 没有关系，当终端和 sshd 的连接断开时，虽然 pts/0 会被关闭，和它相关的 shell 和 tmux 客户端也将被 kill 掉，但不会影响 tmux 服务器，当下次再用 tmux 客户端连上 tmux 服务器时，看到的还是上次的内容。

## TTY 和 PTS 的区别

从上面的流程中应该可以看出来了，对用户空间的程序来说，他们没有区别，都是一样的；从内核里面来看，pts 的另一端连接的是 ptmx，而 tty 的另一端连接的是内核的终端模拟器，ptmx 和终端模拟器都只是负责维护会话和转发数据包；再看看 ptmx 和内核终端模拟器的另一端，ptmx 的另一端连接的是用户空间的应用程序，如 sshd、tmux 等，而内核终端模拟器的另一端连接的是具体的硬件，如键盘和显示器。

## 常见的 TTY 配置

先先来看看当前 tty 的所有配置：

```
dev@dev:~$ stty -a
speed 38400 baud; rows 51; columns 204; line = 0;
intr = ^C; quit = ^; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc ixany imaxbel -iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc
```

> stty 还可以用来修改 tty 的参数，用法请参考 `man stty`

只要是有权限的程序，都可以通过 Linux 提供的 API 来修改 TTY 的配置，下面介绍一些常见的的配置项。

#### rows 51; columns 204;

这个配置一般由终端控制，当终端的窗口大小发生变化时，需要通过一定的手段修改该配置，比如 ssh 协议里面就有修改窗口大小的参数，sshd 收到客户端的请求后，会通过 API 修改 tty 的这个参数，然后由 tty 通过信号 SIGWINCH 通知前端程序（比如 shell 或者 vim），前端程序收到信号后，再去读 tty 的这个参数，然后就知道如何调整自己的输出排版了。

#### intr = ^C

tty 除了在终端和前端进程之间转发数据之外，还支持很多控制命令，比如终端输入了 CTRL+C，那么 tty 不会将该输入串转发给前端进程，而是将它转换成信号 SIGINT 发送给前端进程。这个就是用来配置控制命令对应的输入组合的，比如我们可以配置 "intr = ^E" 表示用 CTRL+E 代替 CTRL+C。

#### start = ^Q; stop = ^S;

这是两个特殊的控制命令，估计经常有人会碰到，在键盘上不小心输入 CTRL+S 后，终端没反应了，即没输出，也不响应任何输入。这是因为这个命令会告诉 TTY 暂停，阻塞所有读写操作，即不转发任何数据，只有按了 CTRL+Q 后，才会继续。这个功能应该是历史遗留，以前终端和服务器之间没有流量控制功能，所以有可能服务器发送数据过快，导致终端处理不过来，于是需要这样一个命令告诉服务器不要再发了，等终端处理完了后在通知服务器继续。

该命令现在比较常用的一个场景就是用 `tail -f` 命令监控日志文件的内容时，可以随时按 CTRL+S 让屏幕停止刷新，看完后再按 CTRL+Q 让它继续刷，如果不这样的话，需要先 CTRL+C 退出，看完后在重新运行 `tail -f` 命令。

#### echo

在终端输入字符的时候，之所以我们能及时看到我们输入的字符，那是因为 TTY 在收到终端发过去的字符后，会先将字符原路返回一份，然后才交给前端进程处理，这样终端就能及时的显示输入的字符。echo 就是用来控制该功能的配置项，如果是 - echo 的话表示 disable echo 功能。

#### -tostop

如果你在 shell 中运行程序的时候，后面添加了 &，比如 `./myapp &`，这样 myapp 这个进程就会在后台运行，但如果这个进程继续往 tty 上写数据呢？这个参数就用来控制是否将输出转发给终端，也即结果会不会在终端显示，这里 "-tostop" 表示会输出到终端，如果配置为 "tostop" 的话，将不输出到终端，并且 tty 会发送信号 SIGTTOU 给 myapp，该信号的默认行为是将暂停 myapp 的执行。

## TTY 相关信号

除了上面介绍配置时提到的 SIGINT，SIGTTOU，SIGWINCHU 外，还有这么几个跟 TTY 相关的信号

#### SIGTTIN

当后台进程读 tty 时，tty 将发送该信号给相应的进程组，默认行为是暂停进程组中进程的执行。暂停的进程如何继续执行呢？请参考下一篇文章中的 SIGCONT。

#### SIGHUP

当 tty 的另一端挂掉的时候，比如 ssh 的 session 断开了，于是 sshd 关闭了和 ptmx 关联的 fd，内核将会给和该 tty 相关的所有进程发送 SIGHUP 信号，进程收到该信号后的默认行为是退出进程。

#### SIGTSTP

终端输入 CTRL+Z 时，tty 收到后就会发送 SIGTSTP 给前端进程组，其默认行为是将前端进程组放到后端，并且暂停进程组里所有进程的执行。

> 跟 tty 相关的信号都是可以捕获的，可以修改它的默认行为

## 结束语

本文介绍了常见的 tty 功能和特点，下一篇中将详细介绍和 tty 密切相关的进程 session id，进程组，job，后台程序等，敬请期待。

## 参考

- [The TTY demystified](http://www.linusakesson.net/programming/tty/index.php)