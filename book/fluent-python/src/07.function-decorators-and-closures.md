> @Date    : 2020-10-24 21:30:33
>
> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo

# Ch7 Function Decorators and Closures

有很多人抱怨，把这个特性命名为“装饰器”不好。主要原因是，这个名称与 GoF 书使用的不一致。装饰器这个名称可能更适合在编译器领域使用，因为它会遍历并注解句法树

—— “PEP 318 — Decorators for Functions and Methods”

nonlocal 是新近出现的保留关键字，在 Python 3.0 中引入。作为 Python 程序员，如果严格遵守基于类的面向对象编程方式，即便不知道这个关键字也不会受到影响。然而，如果你想自己实现函数装饰器，那就必须了解闭包的方方面面，因此也就需要知道 nonlocal

除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础

本章的最终目标是解释清楚函数装饰器的工作原理，包括最简单的注册装饰器和较复杂的参数化装饰器

## 7.1 装饰器基础知识

装饰器是可调用的对象，它处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象

假如有个名为 decorate 的装饰器

```Python
@decorate
def target():
	print('running target()')

# 上述代码的效果与下面效果

def target():
	print('running target()')

target = decorate(target)
```

两种写法的最终结果一样：上述两个代码片段执行完毕后得到的 target 不一定是原来那
个 target 函数，而是 decorate(target) 返回的函数

示例 7-1 装饰器通常把函数替换成另一个函数

```Python
In [1]: def deco(func):
   ...:     def inner():
   ...:         print('running inner()')
   ...:     return inner # 返回 inner 函数对象
   ...:
   ...: @deco
   ...: def target(): # 使用 deco 装饰 target
   ...:     print('running target()')
   ...:

In [2]: target() # 调用被装饰的 target 其实会运行 inner
running inner()

In [3]: target # 审查对象，发现 target 现在是 inner 的引用
Out[3]: <function __main__.deco.<locals>.inner()>
```

严格来说，装饰器只是语法糖。如前所示，装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时

综上，装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行

## 7.2 Python 何时执行装饰器

装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时（即 Python 加载模块时）

```Python
In [4]: registry = [] # registry 保存被 @register 装饰的函数引用
   ...:
   ...: def register(func): # register 的参数是一个函数
   ...:     print('running register(%s)' % func) # 为了演示，显示被装饰的函数
   ...:     registry.append(func)
   ...:     return func # 返回 func：必须返回函数；这里返回的函数与通过参数传入的一样
   ...:
   ...: @register
   ...: def f1():
   ...:     print('running f1()')
   ...:
   ...: @register
   ...: def f2():
   ...:     print('running f2()')
   ...:
   ...: def f3():
   ...:     print('running f3()')
   ...:
   ...: def main():
   ...:     print('running main()')
   ...:     print('registry ->', registry)
   ...:     f1()
   ...:     f2()
   ...:     f3()
   ...:
   ...: if __name__ == '__main__':
   ...:     main()
   ...:
running register(<function f1 at 0x0000024C703493A0>)
running register(<function f2 at 0x0000024C70349280>)
running main()
registry -> [<function f1 at 0x0000024C703493A0>, <function f2 at 0x0000024C70349280>]
running f1()
running f2()
running f3()
```

注意，register 在模块中其他函数之前运行（两次）。调用 register 时，传给它的参数是被装饰的函数，例如 <function f1 at 0x100631bf8>

加载模块后，registry 中有两个被装饰函数的引用：f1 和 f2。这两个函数，以及 f3，只在 main 明确调用它们时才执行

如果导入 registration.py 模块（不作为脚本运行），输出如下

```Python
>>> import registration
running register(<function f1 at 0x10063b1e0>)
running register(<function f2 at 0x10063b268>)
```

此时查看 registry 的值，得到的输出如下

```Python
>>> registration.registry
[<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]
```

示例 7-2 主要想强调，函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这突出了 Python 程序员所说的导入时和运行时之间的区别

考虑到装饰器在真实代码中的常用方式，示例 7-2 有两个不寻常的地方：

1. 装饰器函数与被装饰的函数在同一个模块中定义。实际情况是，装饰器通常在一个模块中定义，然后应用到其他模块中的函数上
2. register 装饰器返回的函数与通过参数传入的相同。实际上，大多数装饰器会在内部定义一个函数，然后将其返回

虽然示例 7-2 中的 register 装饰器原封不动地返回被装饰的函数，但是这种技术并非没有用处。很多 Python Web 框架使用这样的装饰器把函数添加到某种中央注册处，例如把 URL 模式映射到生成 HTTP 响应的函数上的注册处。这种注册装饰器可能会也可能不会修改被装饰的函数

## 7.3 使用装饰器改进“策略”模式

使用注册装饰器可以改进 6.1 节中的电商促销折扣示例，示例 6-6 的主要问题是，定义体中有函数的名称，但是 best_promo 用来判断哪个折扣幅度最大的 promos 列表中也有函数名称。这种重复是个问题，因为新增策略函数后可能会忘记把它添加到 promos 列表中，导致 best_promo 忽略新策略，而且不报错，为系统引入了不易察觉的缺陷。示例 7-3 使用注册装饰器解决了这个问题

示例 7-3 promos 列表中的值使用 promotion 装饰器填充

```Python
promos = [] # promos 列表起初是空的

# promotion 把 promo_func 添加到 promos 列表中，然后原封不动地将其返回
def promotion(promo_func):
    promos.append(promo_func)
    return promo_func

# 被 @promotion 装饰的函数都会添加到 promos 列表中
@promotion
def fidelity(order):
    """为积分为1000或以上的顾客提供5%折扣"""
    return order.total() * .05 if order.customer.fidelity >= 1000 else 0

@promotion
def bulk_item(order):
    """单个商品为20个或以上时提供10%折扣"""
    discount = 0
    for item in order.cart:
        if item.quantity >= 20:
            discount += item.total() * .1
    return discount

@promotion
def large_order(order):
    """订单中的不同商品达到10个或以上时提供7%折扣"""
    distinct_items = {item.product for item in order.cart}
    if len(distinct_items) >= 10:
        return order.total() * .07
    return 0

# best_promos 无需修改，因为它依赖 promos 列表
def best_promo(order):
    """选择可用的最佳折扣
    """
    return max(promo(order) for promo in promos)
```

与 6.1 节给出的方案相比，这个方案有几个优点：

- 促销策略函数无需使用特殊的名称（即不用以 `_promo` 结尾）
- @promotion 装饰器突出了被装饰的函数的作用，还便于临时禁用某个促销策略：只需把装饰器注释掉
- 促销折扣策略可以在其他模块中定义，在系统中的任何地方都行，只要使用 @promotion 装饰即可

不过，多数装饰器会修改被装饰的函数。通常，它们会定义一个内部函数，然后将其返回，替换被装饰的函数。使用内部函数的代码几乎都要靠闭包才能正确运作。为了理解闭包，我们要退后一步，先了解 Python 中的变量作用域

## 7.4 变量作用域规则

示例 7-4 一个函数，读取一个局部变量和一个全局变量


```Python
>>> def f1(a):
... print(a)
... print(b)
...
>>> f1(3)
3
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<stdin>", line 3, in f1
NameError: global name 'b' is not defined
```

> 在 Python 3.5 中，错误信息是 NameError: name 'b' is not defined，删除了 global。——编者注

```Python
>>> b = 6
>>> f1(3)
3
6
```

示例 7-5 b 是局部变量，因为在函数的定义体中给它赋值了

```Python
>>> b = 6
>>> def f2(a):
... 	print(a)
... 	print(b)
... 	b = 9
...
>>> f2(3)
3
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<stdin>", line 3, in f2
UnboundLocalError: local variable 'b' referenced before assignment
```

注意，首先输出了 3，这表明 print(a) 语句执行了。但是第二个语句 print(b) 执行不了。一开始我很吃惊，我觉得会打印 6，因为有个全局变量 b，而且是在 print(b) 之后为局部变量 b 赋值的

可事实是，Python 编译函数的定义体时，它判断 b 是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python 会尝试从本地环境获取 b。后面调用 f2(3) 时， f2 的定义体会获取并打印局部变量 a 的值，但是尝试获取局部变量 b 的值时，发现 b 没有绑定值

这不是缺陷，而是设计选择：Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。这比 JavaScript 的行为好多了，JavaScript 也不要求声明变量，但是如果忘记把变量声明为局部变量（使用 var），可能会在不知情的情况下获取全局变量

如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明

```Python
>>> b = 6
>>> def f3(a):
... 	global b
... 	print(a)
... 	print(b)
... 	b = 9
...
>>> f3(3)
3
6
>>> b
9
>>> f3(3)
3
9
>>> b = 30
>>> b
30
>>>
```

了解 Python 的变量作用域之后，下一节可以讨论闭包了

### 比较字节码

dis 模块为反汇编 Python 函数字节码提供了简单的方式

示例 7-6 反汇编示例 7-4 中的 f1 函数

```Python
>>> from dis import dis
>>> dis(f1)
  2           0 LOAD_GLOBAL              0 (print) # 加载全局名称 print
              2 LOAD_FAST                0 (a) # 加载本地名称 a
              4 CALL_FUNCTION            1
              6 POP_TOP

  3           8 LOAD_GLOBAL              0 (print)
             10 LOAD_GLOBAL              1 (b) # 加载全局名称 b
             12 CALL_FUNCTION            1
             14 POP_TOP
             16 LOAD_CONST               0 (None)
             18 RETURN_VALUE
```

示例 7-7 反汇编示例 7-5 中的 f2 函数

```Python
>>> dis(f2)
  2           0 LOAD_GLOBAL              0 (print)
              2 LOAD_FAST                0 (a)
              4 CALL_FUNCTION            1
              6 POP_TOP

  3           8 LOAD_GLOBAL              0 (print)
             10 LOAD_FAST                1 (b) # 加载本地名称 b。这表明，编译器把 b 视作局部变量，即使在后面才为 b 赋值，因为变量的种类（是不是局部变量）不能改变函数的定义体
             12 CALL_FUNCTION            1
             14 POP_TOP

  4          16 LOAD_CONST               1 (9)
             18 STORE_FAST               1 (b)
             20 LOAD_CONST               0 (None)
             22 RETURN_VALUE
```

运行字节码的 CPython VM 是栈机器，因此 LOAD 和 POP 操作引用的是栈。深入说明 Python 操作码不在本书范畴之内，不过 dis 模块的文档（http://docs.python.org/3/library/dis.html ）对其做了说明

## 7.5 闭包

在博客圈，人们有时会把闭包和匿名函数弄混。这是有历史原因的：在函数内部定义函数不常见，直到开始使用匿名函数才会这样做。而且，只有涉及嵌套函数时才有闭包问题。因此，很多人是同时知道这两个概念的

其实，闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量

假如有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值；例如，整个历史中某个商品的平均收盘价。每天都会增加新价格，因此平均值要考虑至目前为止所有的价格

比如你像这样调用：

```Python
>>> avg(10)
10.0
>>> avg(11)
10.5
>>> avg(12)
11.0
```

初学者可能像下面实现

示例 7-8 average_oo.py：计算移动平均值的类

```Python
class Averager():
	def __init__(self):
		self.series = []

	def __call__(self, new_value):
		self.series.append(new_value)
		total = sum(self.series)
		return total/len(self.series)
```

示例 7-9 average.py：计算移动平均值的高阶函数

```Python
def make_averager():
	series = []

	def averager(new_value):
		series.append(new_value)
		total = sum(series)
		return total/len(series)

	return averager
```

调用 make_averager 时，返回一个 averager 函数对象。每次调用 averager 时，它会把参数添加到系列值中，然后计算当前平均值

示例 7-10 测试示例 7-9

```Python
>>> avg = make_averager()
>>> avg(10)
10.0
>>> avg(11)
10.5
>>> avg(12)
11.0
```

注意，这两个示例有共通之处：调用 Averager() 或 make_averager() 得到一个可调用对象 avg，它会更新历史值，然后计算当前均值。在示例 7-8 中，avg 是 Averager 的实例；在示例 7-9 中是内部函数 averager。不管怎样，我们都只需调用 avg(n)，把 n 放入系列值中，然后重新计算均值

Averager 类的实例 avg 在哪里存储历史值很明显：self.series 实例属性。但是第二个示例中的 avg 函数在哪里寻找 series 呢？

注意，series 是 make_averager 函数的局部变量，因为那个函数的定义体中初始化了 series：series = []。可是，调用 avg(10) 时，make_averager 函数已经返回了，而它的本地作用域也一去不复返了

在 averager 函数中，series 是自由变量（free variable）。这是一个技术术语，指未在本地作用域中绑定的变量，参见图 7-1

-[7-1-averager-的闭包延伸到那个函数的作用域之外.jpg]

审查返回的 averager 对象，我们发现 Python 在 `__code__` 属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称

示例 7-11 审查 make_averager（见示例 7-9）创建的函数

```Python
>>> avg.__code__.co_varnames
('new_value', 'total')
>>> avg.__code__.co_freevars
('series',)
```

series 的绑定在返回的 avg 函数的 `__closure__` 属性中。`avg.__closure__` 中的各个元素对应于 `avg.__code__.co_freevars` 中的一个名称。这些元素是 cell 对象，有个 cell_contents 属性，保存着真正的值

```Python
>>> avg.__code__.co_freevars
('series',)
>>> avg.__closure__
(<cell at 0x107a44f78: list object at 0x107a91a48>,)
>>> avg.__closure__[0].cell_contents
[10, 11, 12]
```

综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定

注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量

## 7.6 nonlocal 声明

前面实现 make_averager 函数的方法效率不高。在示例 7-9 中，我们把所有值存储在历史数列中，然后在每次调用 averager 时使用 sum 求和。更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值

示例 7-13 计算移动平均值的高阶函数，不保存所有历史值，但有缺陷

```Python
def make_averager():
	count = 0
	total = 0

	def averager(new_value):
		count += 1
		total += new_value
		return total / count

	return averager
```

尝试使用示例 7-13 中定义的函数，会得到如下结果：

```Python
>>> avg = make_averager()
>>> avg(10)
Traceback (most recent call last):
...
UnboundLocalError: local variable 'count' referenced before assignment
>>>
```

问题是，当 count 是数字或任何不可变类型时，count += 1 语句的作用其实与 count = count + 1 一样。因此，我们在 averager 的定义体中为 count 赋值了，这会把 count 变成局部变量。total 变量也受这个问题影响

示例 7-9 没遇到这个问题，因为我们没有给 series 赋值，我们只是调用 series.append，并把它传给 sum 和 len。也就是说，我们利用了列表是可变的对象这一事实

但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如 count = count + 1，其实会隐式创建局部变量 count。这样，count 就不是自由变量了，因此不会保存在闭包中

为了解决这个问题，Python 3 引入了 nonlocal 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为 nonlocal 声明的变量赋予新值，闭包中保存的绑定会更新。最新版 make_averager 的正确实现如示例 7-14 所示

示例 7-14 计算移动平均值，不保存所有历史（使用 nonlocal 修正）

```Python
def make_averager():
	count = 0
	total = 0

	def averager(new_value):
		nonlocal count, total
		count += 1
		total += new_value
		return total / count

	return averager
```

## 7.7 实现一个简单的装饰器

