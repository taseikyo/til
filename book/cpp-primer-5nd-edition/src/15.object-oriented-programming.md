# 15. Object-Oriented Programming

面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定

继承和动态绑定对程序的编写有两方面的影响：

1. 我们可以更容易地定义与其他类相似但不完全相同的新类
2. 在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别

## OOP: 概述

面向对象程序设计 (object-oriented programming) 的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离 (见第 7 章); 使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

### 继承

通过**继承** (inheritance) 联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类** (base class), 其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类** (derived class). 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

在 C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数** (virtual function)

```c++
class Quote {
  public:
	std::string isbn() const;
	virtual double net_price(std::size_t n) const;
};
```

派生类必须通过使用**类派生列表** (class derivation list) 明确指出它是从哪个 (哪些) 基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:

```c++
class Bulk_quote: public Quote { //Bulk_quote 继承了 Quote
  public:
	double net_price(std::size_t) const override;
};
```

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字，但是并不是非得这么做。出于 15.3 节 (第 538 页) 将要解释的原因，C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 override 关键字

### 动态绑定

通过使用**动态绑定** (dynamic binding), 我们能用同一段代码分别处理 Quote 和 Bulk_quote 的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用:

```c++
// 计算并打印销售给定数量的某种书籍所得的费用
double print_total(ostream &os, const Quote &item, size_t n) {
// 根据传入 item 形参的对象类型调用 Quote::net price
// 或者 Bulk_quote::net_price
	double ret = item.net_price(n);
	os << "ISBN:" << item.isbn() // 调用 Quote::isbn
	   << "#sold:" << n << "total due:" << ret << endl;
	return ret;
}
```

关于上面的函数有两个有意思的结论：因为函数 print_total 的 item 形参是基类 Quote 的一个引用，所以出于 15.2.3 节 (第 534 页) 将要解释的原因，我们既能使用基类 Quote 的对象调用该函数，也能使用派生类 Bulk_quote 的对象调用它；又因为 print_total 是使用引用类型调用 net_price 函数的，所以出于 15.2.1 节 (第 528 页) 将要解释的原因，实际传入 print_total 的对象类型将决定到底执行 net_price 的哪个版本:

```c++
//basic 的类型是 Quote;bulk 的类型是 Bulk_quote
print_total(cout, basic, 20);// 调用 Quote 的 net_price
print_total(cout, bulk, 20);// 调用 Bulk_quote 的 net_price
```

因为在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为**运行时绑定** (run-time binding)

在 C++ 语言中，当我们使用基类的引用 (或指针) 调用一个虚函数时将发生动态绑定

### 定义基类

```c++
class Quote {
  public:
	Quote() = default; // 关于 = default 请7.1.4 节(第 237 页)
	Quote(const std::string &book, double sales_price): bookNo(book), price(sales_price) {}
	std::string isbn() const {return bookNo;}
// 返回给定数量的书籍的销售总额
// 派生类负责改写并使用不同的折扣计算算法
	virtual double net_price(std::size_t n) const {
		return n * price;
	}
	virtual ~Quote() = default; // 对析构函数进行动态绑定
  private:
	std::string bookNo;// 书籍的 ISBN 编号
  protected: double price = 0.0; // 代表普通状态下不打折的价格
};
```

我们将在 15.7.1 节详细介绍虚析构函数的知识，现在只需记住作为继承关系中根节点的类通常都会定义一个虚析构函数

**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此**

### 成员函数与继承

派生类可以继承其基类的成员，然而当遇到如 net_price 这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以**覆盖** (override) 从基类继承而来的旧定义

在 C++ 语言中，基类必须将它的两种成员函数区分开来：

1. 基类希望其派生类进行覆盖的函数
2. 基类希望派生类直接继承而不要改变的函数

对于前者，基类通常将其定义为**虚函数** (virtual). 当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本

基类通过在其成员函数的声明语句之前加上关键字 virtual 使得该函数执行动态绑定。任何构造函数之外的非静态函数 (7.6 节，第 268 页) 都可以是虚函数。关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。isbn 函数的执行与派生类的细节无关，不管作用于 Quote 对象还是 Bulk_quote 对象，isbn 函数的行为都一样。在我们的继承层次关系中只有一个 isbn 函数，因此也就不存在调用 isbn() 时到底执行哪个版本的疑问

### 定义派生类

派生类必须通过使用类派生列表 (class derivation list) 明确指出它是从哪个 (哪些) 基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个:public、protected 或者 private

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的 Bulk_quote 类必须包含一个 net_price 成员:

```c++
class Bulk_quote: public Quote { //Bulk_quote 继承自 Quote
  public:
	Bulk_quote() =default;
	Bulk_quote(const std::strings, double, std::size_t, double);
// 覆盖基类的函数版本以实现基于大量购买的折扣政策
	double net_price(std::size_t) const override;
  private:
	std::size_t min_qty = 0; // 适用折扣政策的最低购买量
	double discount = 0.0; // 以小数表示的折扣额
};
```

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型的对象绑定到基类的引用或指针上

大多数类都只继承自一个类，这种形式的继承被称作 “单继承”, 它构成了本章的主题。关于派生列表中含有多于一个基类的情况将在 18.3 节 (第 710 页) 中介绍

### 派生类中的虚函数

派生类经常 (但不总是) 覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。派生类可以在它覆盖的函数前使用 virtual 关键字，但不是非得这么做。我们将在 15.3 节 (第 538 页) 介绍其原因，C++11 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数 (7.1.2 节，第 231 页) 的 const 关键字后面、或者在引用成员函数 (13.6.3 节，第 483 页) 的引用限定符后面添加一个关键字 override

### 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：一个含有派生类自己定义的 (非静态) 成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个 Bulk_quote 对象将包含四个数据元素：它从 Quote 继承而来的 bookNo 和 price 数据成员，以及 Bulk_quote 自己定义的 min_gty 和 discount 成员

C++ 标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为 Bulk_quote 的对象包含如下图所示的两部分

|                        |  Bulk_quote 对象 |
|:----------------------:|:----------------:|
| 从Quote继承而来的成员  | bookNo price     |
| Bulk_quote自定义的成员 | min_gty discount |

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上

```c++
Quote item;// 基类对象
Bulk_quote bulk;
Quote *p = &item; //p 指向 Quote 对象
p = &bulk; //p 指向 bulk 的 Quote 部分
Quote &r = bulk; //r 绑定到 bulk 的 Quote
```

部分这种转换通常称为**派生类到基类的** (derived-to-base) 类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换 (4.11 节，第 141 页)

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方

**在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在**

### 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分

**每个类控制它自己的成员初始化过程**

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段 (7.5.1 节，第 258 页) 执行初始化操作的。类似于我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的 Bulk_quote 构造函数如下所示:

```c++
Bulk_quote(const std::strings book, double p, std::size_t gty,
           double disc): Quote(book, p), min_gty(qty), discount(disc) {}
```

该函数将它的前两个参数 (分别表示 ISBN 和价格) 传递给 Quote 的构造函数，由 Quote 的构造函数负责初始化 Bulkquote 的基类部分 (即 bookNo 成员和 price 成员). 当 (空的) Quote 构造函数体结束后，我们构建的对象的基类部分也就完成初始化了。接下来初始化由派生类直接定义的 min_qty 成员和 discount 成员。最后运行 Bulk_quote 构造函数的 (空的) 函数体

除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化. 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分

**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员**

### 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员:

```c++
// 如果达到了购买书籍的某个最低跟量值，就可以享受折扣价格了
double Bulk_quote::net_price(sizet cnt) const {
	if (cnt >= min_qty) return cnt * (1 - discount) * price;
	else return cnt * price;
}
```

我们将在 15.6 节 (第 547 页) 进一步讨论作用域，目前只需要了解派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员 (例如 min_gty 和 discount) 的方式与使用基类成员 (例如 price) 的方式没什么不同

### 关键概念：遵循基类的接口

必须明确：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此

因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员

### 继承与静态成员

如果基类定义了一个静态成员, 则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例

```c++
class Base {
  public:
	static void statmem();
};

class Derived: public Base {
	void f(const Derived&);
};
```

静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它:

```c++
void Derived::f(const Derived &derived_obj) {
	Base::statmem();// 正确：Base 定义了 statmem
	Derived::statmem();// 正确：Derived 继承了 statmem
	// 正确：派生类的对象能访问基类的静态成员
	derived_obj.statmem();// 通过 Derived 对象访问
	statmem();
	// 通过 this 对象访问
}
```

### 派生类的声明

派生类的声明与其他类差别不大 (7.3.3 节，第 250 页), 声明中包含类名但是不包含它的派生列表:

```c++
class Bulk_quote: public Quote;// 错误：派生列表不能出现在这里
class Bulk_quote;// 正确：声明派生类的正确方式
```

一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现

### 被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明:

```c++
class Quote; // 声明但未定义
// 错误：Quote 必须被定义
class Bulk_quote:public Quote {...};
```

派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身. 一个类是基类，同时它也可以是一个派生类:

```c++
class Base {/*..*/};
class D1:public Base{/*...*/};
class D2:public D1{/*...*/};
```

在这个继承关系中，Base 是 D1 的**直接基类** (direct base), 同时是 D2 的**间接基类** (indirect base). 直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来

### 防止继承的发生

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final:

```c++
class NoDerived final {/* */}; //NoDerived 不能作为基类
class Base {/**/};
//Last 是 final 的；我们不能继承 Last
class last final: Base {/**/};//Last 不能作为基类
class Bad:NoDerived {/**/};// 错误：NoDerived 是 final 的
class Bad2:Last {/**/}; // 错误：Last 是 final 的
```

### 类型转换与继承

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致 (2.3.1 节，第 46 页和 2.3.2 节，第 47 页), 或者对象的类型含有一个可接受的 const 类型转换规则 (4.11.2 节). 存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用 (或指针) 时，实际上我们并不清楚该引用 (或指针) 所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象

和内置指针一样，智能指针类 (12.1 节) 也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内

### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型 (static type) 与该表达式表示对象的动态类型 (dynamic type) 区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。**动态类型直到运行时才可知**

我们知道 item 的静态类型是 Quote&, 它的动态类型则依赖于 item 绑定的实参，动态类型直到在运行时调用该函数时才会知道。如果我们传递一个 Bulk_quote 对象给 print_total, 则 item 的静态类型将与它的动态类型不一致

**如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致**。例如，Quote 类型的变量永远是一个 Quote 对象，我们无论如何都不能改变该变量对应的对象的类型

### 不存在从基类向派生类的隐式类型转换

之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员

因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换:

```c++
Quote base;
Bulk_quote *bulkP = &base;// 错误：不能将基类转换成派生类
Bulk_quote &bulkRef = base;// 错误：不能将基类转换成派生类
```

如果上述赋值是合法的，则我们有可能会使用 bulkP 或 bulkRef 访问 base 中本不存在的成员

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换:

```c++
Bulk_quote bulk;
Quote *itemP = &bulk;// 正确：动态类型是 Bulk_quote
Bulk_quote *bulkP = itemP; // 错误：不能将基类转换成派生类
```

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用 dynamic_cast (19.2.1 节，第 730 页) 请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 static_cast (4.11.3 节，第 144 页) 来强制覆盖掉编译器的检查工作

### 在对象之间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别

请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数 (13.1.1 节); 而当执行赋值操作时，我们调用赋值运算符 (13.1.2 节). 这些成员通常都包含一个参数，该参数的类型是类类型的 const 版本的引用

因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员

例如，我们的书店类使用了合成版本的拷贝和赋值操作 (13.1.1 节). 关于拷贝控制与继承的知识将在 15.7.2 节做更详细的介绍，现在我们只需要知道合成版本会像其他类一样逐成员地执行拷贝或赋值操作:

```c++
Bulk_quote bulk;// 派生类对象
Quote item(bulk);// 使用 Quote::Quote (const Quote&) 构造函数 
item = bulk;// 调用 Quote::operator=(const Quote&)
```

当构造 item 时，运行 Quote 的拷贝构造函数。该函数只能处理 bookNo 和 price 两个成员，它负责拷贝 bulk 中 Quote 部分的成员，同时忽略掉 bulk 中 Bulk_quote 部分的成员

因为在上述过程中会忽略 Bulk_quote 部分，所以我们可以说 bulk 的 Bulk_quote 部分被**切掉** (sliced down) 了

### 关键概念：存在继承关系的类型之间的转换规则

要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要:

- 从派生类向基类的类型转换只对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在 15.5 节 (第 544 页) 详细介绍可访问性的问题

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然 (显式或隐式地) 定义了拷贝控制成员. 因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分

## 虚函数

在 C++ 中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定. 因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义 (6.1.2 节. 但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数

### 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数

举个例子，考虑 15.1 节 (第 527 页) 的 print_total 函数，该函数通过其名为 item 的参数来进一步调用 net_price, 其中 item 的类型是 Quote&. 因为 item 是引用而且 net_price 是虚函数，所以我们到底调用 net_price 的哪个版本完全依赖于运行时绑定到 item 的实参的实际 (动态) 类型:

```c++
Quote base("0-201-82470-1",50);
print_total(cout,base,10);// 调用 Quote::net_price
Bulk_quote derived("0-201-82470-1",50,5,.19);
print_total(cout,derived,10);// 调用 Bulk_quote::net_price
```

必须要搞清楚的一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生

```c++
base = derived;// 把 derived 的 Quote 部分拷贝给 base
base.net_price(20);// 调用 Quote::net_price
```

当我们通过一个具有普通类型 (非引用非指针) 的表达式调用虚函数时，在编译时就会将调用的版本确定下来。例如，如果我们使用 base 调用 netprice, 则应该运行 net_price 的哪个版本是显而易见的。我们可以改变 base 表示的对象的值 (即内容), 但是不会改变该对象的类型。因此，在编译时该调用就会被解析成 Quote 的 net_price

### 关键概念：C++ 的多态性

OOP 的核心思想是多态性 (polymorphism)，其含义是“多种形式”. 我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的 “多种形式” 而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是 C++ 语言支持多态性的根本所在

当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型

另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数 (虚函数或非虚函数) 调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上

**当且仅当对通过指针或引用调用虚函教时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同**

## 派生类中的虚函数

当我们在派生类中覆盖了某个虚函数时，可以再一次使用 virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型、返回类型必须与被它覆盖的基类函数完全一致

该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果 D 由 B 派生得到，则基类的虚函数可以返回 B* 而派生类的对应函数可以返回 D* , 只不过这样的返回类型要求从 D 到 B 的类型转换是可访问的. 15.5 节 (第 544 页) 将介绍如何确定一个基类的可访问性，在 15.8.1 节 (第 561 页) 中我们将看到这种虚函数的一个实际例子

**基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配**

### final 和 override 说明符

如我们将要在 15.6 节 (第 550 页) 介绍的，派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了

要想调试并发现这样的错误显然非常困难。在 C++1l 新标准中我们可以使用 override 关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用 override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错:

```c++
struct B {
	virtual void fld(int) const;
	virtual void f2d();
	void f3d();
};

struct D1: B {
	void fld(int) const override; // 正确:f1 与基类中的 f1 匹配
	void f2d(int) override;// 错误：B 没有形如 f2d(int) 的函数
	void f3d() override; // 错误:f3 不是虚函数
	void f4d() override;// 错误：B 没有名为 f4 的函数
};
```

因为只有虚函数才能被覆盖，所以编译器会拒绝 D1 的 f3. 该函数不是 B 中的虚函数，因此它不能被覆盖。类似的，f4 的声明也会发生错误，因为 B 中根本就没有名为 f4 的函数

我们还能把某个函数指定为 final, 如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误:

```c++
struct D2: B {
	// 从 B 继承 f2() 和 f3(), 覆盖 f1(int)
	void f1(int) const final;// 不允许后续的其他类覆盖 f1(int)
};

struct D3: D2 {
	voidf2();// 正确：覆盖从间接基类 B 继承而来的 f2
	void f1(int) const;// 错误：D2 已经将 f2 声明成 final
};
```

final 和 override 说明符出现在形参列表 (包括任何 const 或引用修饰符) 以及尾置返回类型 (6.3.3 节) 之后

### 虚函数与默认实参

和其他函数一样，虚函数也可以拥有默认实参 (6.5.1 节，第 211 页). 如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符

**如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致**

### 回避虚函数的机制

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的

// 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么
`double undiscounted = baseP->Quote::net_price(42);` 该代码强行调用 Quote 的 net_price 函数，而不管 baseP 实际指向的对象类型到底是什么。该调用将在编译时完成解析

**通常情况下，只有成员函数 (或友元) 中的代码才需要使用作用城运算符来回避虚函数的机制**

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作

**如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归**

## 抽象基类

### 纯虚函数

我们可以将 net_price 定义成纯虚 (pure virtual) 函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个 net_price 函数是没有实际意义的。和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置 (即在声明语句 15.4 抽象基类
的分号之前) 书写 =0 就可以将一个虚函数说明为纯虚函数。其中，=0 只能出现在类内部的虚函数声明语句处:

```c++
// 用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略
class Disc_quote: public Quote {
  public:
	Disc_quote() =default;
	Disc_quote(const std::strings book, double price, std::size t gty, double disc): Quote(book, price), quantity(qty), discount(disc) {}
  	double net price(std::size_t) const =0;
  protected:
	std::size_tquantity = 0; // 折扣适用的购买量
	double discount = 0.0; // 表示折扣的小数值
};
```

和我们之前定义的 Bulk_quote 类一样，Disc_quote 也分别定义了一个默认构造函数和一个接受四个参数的构造函数。尽管我们不能直接定义这个类的对象，但是 Disc_quote 的派生类构造函数将会使用 Disc_quote 的构造函数来构建各个派生类对象的 Disc_quote 部分

值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部, 也就是说，我们不能在类的内部为一个 =0 的函数提供函数体

### 含有纯虚函数的类是抽象基类

含有 (或者未经覆盖直接继承) 纯虚函数的类是抽象基类 (abstract base class). 抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能 (直接) 创建一个抽象基类的对象。因为 Disc_quote 将 net_price 定义成了纯虚函数，所以我们不能定义 Disc_quote 的对象。我们可以定义 Disc_quote 的派生类的对象，前提是这些类覆盖了 net_price 函数:

```c++
//Discquote 声明了纯虚函数，而 Bulk_quote 将覆盖该函数
Disc_quote discounted;// 错误：不能定义 Disc_quote 的对象
Bulk_quote bulk;// 正确：Bulk_quote 中没有纯虚函数
```

Disc_quote 的派生类必须给出自己的 net_price 定义，否则它们仍将是抽象基类

### 派生类构造函数只初始化它的直接基类

接下来可以重新实现 Bulk_quote 了，这一次我们让它继承 Discquote 而非直接继承 Quote:

```c++
// 当同一书籍的销售量超过某个值时启用折扣
// 折扣的值是一个小于 1 的正的小数值，以此来降低正常销售价格
class Bulk_quote: public Disc_quote {
  public:
	Bulk_quote() =default;
	Bulk_quote(const std::strings book, double price, std::size_t qty, double disc): Disc_quote(book, price, gty, disc) {}
// 覆益基类中的函数版本以实现一种新的折扣策略
	double net_price(std::size_t) const override;
};
```

这个版本的 Bulk_quote 的直接基类是 Disc_quote, 间接基类是 Quote. 每个 Bulk_quote 对象包含三个子对象：一个 (空的) Bulk_quote 部分、一个 Disc_quote 子对象和一个 Quote 子对象

每个类各自控制其对象的初始化过程。因此，即使 Bulk_quote 没有自己的数据成员，它也仍然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给 Disc_quote 的构造函数，随后 Disc_quote 的构造函数继续调用 Quote 的构造函数. Quote 的构造函数首先初始化 bulk 的 bookNo 和 price 成员，当 Quote 的构造函数结束后，开始运行 Disc_quote 的构造函数并初始化 quantity 和 discount 成员，最后运行 Bulkquote 的构造函数，该函数无须执行实际的初始化或其他工作

### 关键概念：重构

在 Quote 的继承体系中增加 Disc_quote 类是重构 (refactoring) 的一个典型示例。重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普递的现象

值得注意的是，即使我们改变了整个继承体系，那些使用了 Bulk_quote 或 Quote 的代码也无须进行任何改动。不过一旦类被重构 (或以其他方式被改变), 就意味着我们必须重新编译含有这些类的代码了

## 访问控制与继承

每个类分别控制自己的成员初始化过程, 与之类似，每个类还分别控制着其成员对于派生类来说是否可访问 (accessible)

### 受保护的成员

一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员. protected 说明符可以看做是 public 和 private 中和后的产物:

- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的
- 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的
- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权

为了理解最后一条规则，请考虑如下的例子:

```c++
class Base {
  protected:
	int prot_mem; //protected 成员
};

class Sneaky: public Base {
	friend void clobber(Sneaky&);// 能访问 Sneaky::prot_mem
	friend void clobber(Base&);// 不能访问 Base::prot_mem
	int j; //j 默认是 private
};
// 正确:clobber 能访问 Sneaky 对象的 private 和 protected 成员
void clobber(Sneaky&s) {s.j = s.prot_mem = 0;}
// 错误:clobber 不能访问 Base 的 protected 成员
void clobber(Base&b) {b.prot_mem = 0;}
```

### 公有、私有和受保护继承

某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符

```c++
class Base {
  public:
	void pub_mem(); //public 成员
  protected:
	int prot_mem; //protected 成员
  private:
	char priv_mem;//private 成员
};

struct Pub_Derv: public Base {
// 正确：派生类能访问 protected 成员
	int f() {return prot_mem;}
// 错误:private 成员对于派生类来说是不可访问的
	char g() {return priv_mem;}
};

struct Priv_Derv: private Base {
//private 不影响派生类的访问权限
	int f1() const {
		return prot_mem;
	}
};
```

派生访问说明符对于派生类的成员 (及友元) 能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关. Pub_Derv 和 Priv_Derv 都能访问受保护的成员 prot_mem, 同时它们都不能访问私有成员 priv_mem

派生访问说明符的目的是控制派生类用户 (包括派生类的派生类在内) 对于基类成员的访问权限:

```c++
pub_Derv d1;// 继承自 Base 的成员是 public
Priv_Derv d2; // 继承自 Base 的成员是 private
dl.pub_mem();// 正确:pub_mem 在派生类中是 public
d2.pub_mem ():// 错误:pub_mem 在派生类中是 private
```

Pub_Derv 和 Priv_Derv 都继承了 pub_mem 函数。如果继承是公有的，则成员将遵循其原有的访问说明符，此时 d1 可以调用 pub_mem. 在 Priv Derv 中，Base 的成员是私有的，因此类的用户不能调用 pub_mem

派生访问说明符还可以控制继承自派生类的新类的访问权限:

```c++
struct Derived_from_Public: public Pub_Derv {
// 正确：Base::prot_mem 在 Pub_Derv 中仍然是 protected
	int use_base() {return prot_mem;}
};

struct Derived_from_Private: public
	Priv_Derv { // 错误：Base::prot_mem 在 Priv_Derv 中是 private
	int use_base() {return prot_mem;}
};
```

假设我们之前还定义了一个名为 Prot_Derv 的类，它采用受保护继承，则 Base 的所有公有成员在新定义的类中都是受保护的. Prot_Derv 的用户不能访问 pub_mem, 但是 Prot_Derv 的成员和友元可以访问那些继承而来的成员

### 派生类向基类转换的可访问性

派生类向基类的转换 (15.2.2 节，第 530 页) 是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定 D 继承自 B:

- 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换
- 不论 D 以什么方式继承 B, D 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的
- 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能使用

**对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行**

### 关键概念：类的设计与受保护的成员

不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者

其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有 (接口) 成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有 (实现) 部分

如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员

和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的

### 友元与继承

就像友元关系不能传递一样 (7.3.4 节，第 250 页), 友元关系同样也不能继承

基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员:

```c++
class Base {
// 添加 friend 声明，其他成员与之前的版本一致
	friend class Pa1; //Pal 在访问 Base 的派生类时不具有特殊性
};
class Pal {
  public:
	int f(Base b) {
		return b.prot_mem;
	}// 正确：Pal 是 Base 的友元
	int f2(Sneaky s) {
		return s.j;
	}// 错误：Pa1 不是 Sneaky 的友元
	// 对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
	int f3(Sneaky s) {return s.prot_mem;} // 正确：Pal 是 Base 的友元
};
```

每个类负责控制自己的成员的访问权限，因此尽管看起来有点儿奇怪，但 f3 确实是正确的. Pa1 是 Base 的友元，所以 Pa1 能够访问 Base 对象的成员，这种可访问性包括了 Base 对象内嵌在其派生类对象中的情况

## 改变个别成员的可访问性

有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明 (3.1 节) 可以达到这一目的:

```c++
class Base {
  public:
	std::sizet size () const {return n;}
  protected:
	std::size_t n;
};

class Derived: private Base { // 注意:private 继承
  public:
// 保持对象尺寸相关的成员的访问级别
	using Base::size;
  protected:
	using Base::n
};
```

因为 Derived 使用了私有继承，所以继承而来的成员 size 和 n (在默认情况下) 是 Derived 的私有成员。然而，我们使用 using 声明语句改变了这些成员的可访问性。改变之后，Derived 的用户将可以使用 size 成员，而 Derived 的派生类将能使用 n

通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员 (例如，非私有成员) 标记出来. using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定

**派生类只能为那些它可以访问的名字提供 using 声明**

### 默认的继承保护级别

在 7.2 节 (第 240 页) 中我们曾经介绍过使用 struct 和 class 关键字定义的类具有不同的默认访问说明符

默认情况下，使用 class 关键字定义的派生类是私有继承的；而使用 struct 关键字定义的派生类是公有继承的:

```c++
class Base {/*...*/};
struct D1:Base {/*...*/};// 默认 public 继承
class D2:Base {/*..…*/};// 默认 private 继承
```

人们常常有一种错觉，认为在使用 struct 关键字和 class 关键字定义的类之间还有更深层次的差别。事实上，**唯一的差别就是默认成员访问说明符及默认派生访问说明符**；除此之外，再无其他不同之处

**一个私有派生的类最好显式地将 private 声明出来，而不要仅仅依赖于默认的设置**

## 继承中的类作用域

每个类定义自己的作用域 (7.4 节), 在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套 (2.2.4 节，第 43 页) 在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义

派生类的作用域位于基类作用域之内这一事实可能有点儿出人意料，毕竟在我们的程序文本中派生类和基类的定义是相互分离开来的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员

```c++
Bulk_quote bulk;
cout<<bulk.isbn();
```

名字 isbn 的解析将按照下述过程所示:

- 因为我们是通过 Bulk_quote 的对象调用 isbn 的，所以首先在 Bulk_quote 中查找，这一步没有找到名字 isbn
- 因为 Bulk_quote 是 Disc_quote 的派生类，所以接下来在 Disc_quote 中查找，仍然找不到
- 因为 Disc_quote 是 Quote 的派生类，所以接着查找 Quote; 此时找到了名字 isbn, 所以我们使用的 isbn 最终被解析为 Quote 中的 isbn

### 在编译时进行名字查找

一个对象、引用或指针的静态类型 (15.2.3 节) 决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致 (当使用基类的引用或指针时会发生这种情况), 但是我们能使用哪些成员仍然是由静态类型决定的。举个例子，我们可以给 Disc_quote 添加一个新成员，该成员返回一个存有最小 (或最大) 数量及折扣价格的 pair (11.2.3 节，第 379 页):

```c++
class Disc_quote: public Quote {
  public:
	std::pair<size_t, double>discount_policy() const {return {quantity, discount};}
// 其他成员与之前的版本一致
};
```

我们只能通过 Disc_quote 及其派生类的对象、引用或指针使用 discount_policy:

```c++
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk; // 静态类型与动态类型一致
Quote *itemP = &bulk; // 静态类型与动态类型不一致
bulkP->discount_policy();// 正确:bulkP 的类型是 Bulk_quote*
itemP->discount_policy();// 错误:itemP 的类型是 Quote*
```

尽管在 bulk 中确实含有一个名为 discount_policy 的成员，但是该成员对于 itemP 却是不可见的. itemP 的类型是 Quote 的指针，意味着对 discount_policy 的搜索将从 Quote 开始。显然 Quote 不包含名为 discount_policy 的成员，所以我们无法通过 Quote 的对象、引用或指针调用 discount_policy

### 名字冲突与继承

和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域 (即派生类) 的名字将隐藏定义在外层作用域 (即基类) 的名字 (2.2.4 节，第 43 页):

```c++
struct Base {
	Base(): mem(0) {}
  protected:
  	int mem;
};

struct Derived: Base {
	Derived(int i): mem(i) {} // 用 i 初始化 Derived::mem
//Base::mem 进行默认初始化
	int get_mem() {return mem;} // 返回 Derived::mem
  protected:
  	int mem; // 隐藏基类中的 mem
};
```

get_mem 中 mem 引用的解析结果是定义在 Derived 中的名字，下面的代码

```c++
Derived d(42);
cout<<d.get_mem()<<endl;// 打印 42 的输出结果将是 42.
```

**派生类的成员将隐藏同名的基类成员**

### 通过作用域运算符来使用隐藏的成员

我们可以通过作用域运算符来使用一个被隐藏的基类成员:

```c++
struct Derived: Baset {
	int get_base_mem() {return Base::mem;}
};
```

作用域运算符将覆盖掉原有的查找规则，并指示编译器从 Base 类的作用域开始查找 mem. 如果使用最新的 Derived 版本运行上面的代码，则 d.get_mem () 的输出结果将是 0.

**除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字**

### 关键概念：名字查找与继承

理解函数调用的解析过程对于理解 C++ 的继承至关重要，假定我们调用 p->mem () (或者 obj.mem()), 则依次执行以下 4 个步骤:

- 首先确定 p (或 obj) 的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型
- 在 p (或 obj) 的静态类型对应的类中查找 mem. 如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找递了该类及其基类仍然找不到，则编译器将报错
- 一旦找到了 mem, 就进行常规的类型检查 (6.1 节，第 183 页) 以确认对于当前找到的 mem, 本次调用是否合法
- 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码:
	- 如果 mem 是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型
	- 反之，如果 mem 不是虚函数或者我们是通过对象 (而非引用或指针) 进行的调用，则编译器将产生一个常规函数调用

### 一如往常，名字查找先于类型检查

声明在内层作用域的函数并不会重载声明在外层作用域的函数 (6.4.1 节，第 210 页). 因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类 (即内层作用域) 的成员与基类 (即外层作用域) 的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉:

```c++
struct Base {
	int memfcn();
};

struct Derived: Base {
	int memfcn(int);// 隐藏基类的 memfcn
};

Derived d;
Base b;
b.memfcn();// 调用 Base::memfcn
d.memfcn(10);// 调用 Derived::memfcn
d.memfcn();// 错误：参数列表为空的 memfcn 被隐藏了
d.Base::memfcn();// 正确：调用 Base::memfcn
```

Derived 中的 memfcn 声明隐藏了 Base 中的 memfcn 声明。在上面的代码中前两条调用语句容易理解，第一个通过 Base 对象 b 进行的调用执行基类的版本；第二个通过 d 进行的调用执行 Derived 的版本；第三条调用语句有点特殊，d.memfcn () 是非法的

为了解析这条调用语句，编译器首先在 Derived 中查找名字 memfcn; 因为 Derived 确实定义了一个名为 memfcn 的成员，所以查找过程终止。一旦名字找到，编译器就不再继续查找了. Derived 中的 memfcn 版本需要一个 int 实参，而当前的调用语句无法提供任何实参，所以该调用语句是错误的

### 虚函数与作用域

我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了 (15.3 节，第 537 页). 假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。例如:

```c++
class Base {
  public:
	virtual int fcn();
};

class D1: public Base {
  public:
	// 隐藏基类的 fcn, 这个 fcn 不是虚函数
	// D1 继承了 Base::fcn() 的定义
	int fcn(int); // 形参列表与 Base 中的 fcn 不一致
	virtual void f2();// 是一个新的虚函数，在 Base 中不存在
};

class D2: public D1 {
  public:
	int fcn(int);// 是一个非虚函数，隐藏了 D1::fcn(int)
	int fcn();// 覆盖了 Base 的虚函数 fcn
	void f2();// 覆盖了 D1 的虚函数 f2
};
```

D1 的 fcn 函数并没有覆盖 Base 的虚函数 fcn, 原因是它们的形参列表不同。实际上，D1 的 fcn 将隐藏 Base 的 fcn. 此时拥有了两个名为 fcn 的函数：一个是 D1 从 Base 继承而来的虚函数 fcn; 另一个是 D1 自己定义的接受一个 int 参数的非虚函数 fcn

### 通过基类调用隐藏的虚函数

给定上面定义的这些类后，我们来看几种使用其函数的方法:

```c++
Base bobj;
D1 d1obj;
D2 d2obj;
Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
bp1->fcn();// 虚调用，将在运行时调用 Base::fcn
bp2->fcn();// 虚调用，将在运行时调用 Base::fcn
bp3->fcn();// 虚调用，将在运行时调用 D2::fcn
D1 *d1p = &d1obj; D2 *d2p = &d2obj;
bp2->f2();// 错误：Base 没有名为 f2 的成员
d1p->f2();// 虚调用，将在运行时调用 D1::f2()
d2p->f2();// 虚调用，将在运行时调用 D2::f2()
```

```c++
Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj;
p1->fcn(42);// 错误：Base 中没有接受一个 int 的 fcn
p2->fcn(42);// 静态绑定，调用 D1::fcn(int)
p3->fcn(42);// 静态绑定，调用 D2::fcn(int)
```

在上面的每条调用语句中，指针都指向了 D2 类型的对象，但是由于我们调用的是非虚函数，所以不会发生动态绑定。实际调用的函数版本由指针的静态类型决定

### 覆盖重载的函数

和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的 0 个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖

有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐

一种好的解决方案是为重载的成员提供一条 using 声明语句 (15.5 节，第 546 页), 这样我们就无须覆盖基类中的每一个重载版本了. using 声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义

类内 using 声明的一般规则同样适用于重载函数的名字 (15.5 节，第 546 页): 基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对 using 声明点的访问

## 构造函数与拷贝控制

位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类 (基类或派生类) 没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成的版本也可以定义成被删除的函数

### 虚析构函数

继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数 (15.2.1 节), 这样我们就能动态分配继承体系中的对象了

当我们 delete 一个动态分配的对象的指针时将执行析构函数 (13.1.3 节). 如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况 (15.2.2 节). 例如，如果我们 delete 一个 Quote * 类型的指针，则该指针有可能实际指向了一个 Bulk_quote 类型的对象

如果这样的话，编译器就必须清楚它应该执行的是 Bulk_quote 的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本:

```c++
class Quote {
public:
	// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
	virtual ~Quote()=default;// 动态绑定析构函数
};
```

和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论 Quote 的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保当我们 delete 基类指针时将运行正确的析构函数版本:

```c++
Quote *itemP = new Quote;// 静态类型与动态类型一致
delete itemP; // 调用 Quote 的析构函数
itemP = new Bulk_quote; // 静态类型与动态类型不一致
delete itemP;// 调用 Bulk_quote 的析构函数
```

**如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为**

之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作 (13.1.4 节). 基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算符或拷贝构造函数

### 虚析构函数将阻止合成移动操作

基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作 (13.6.2 节，第 475 页)

### 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作

- 合成的 Bulk_quote 默认构造函数运行 Disc_quote 的默认构造函数，后者又运行 Quote 的默认构造函数
- Quote 的默认构造函数将 bookNo 成员默认初始化为空字符串，同时使用类内初始值将 price 初始化为 0
- Quote 的构造函数完成后，继续执行 Disc_quote 的构造函数，它使用类内初始值初始化 qty 和 discount
- Disc_quote 的构造函数完成后，继续执行 Bulk_quote 的构造函数，但是它什么具体工作也不做

类似的，合成的 Bulk_quote 拷贝构造函数使用 (合成的) Disc_quote 拷贝构造函数，后者又使用 (合成的) Quote 拷贝构造函数。其中，Quote 拷贝构造函数拷贝 bookNo 和 price 成员；Disc_quote 拷贝构造函数拷贝 qty 和 discount 成员

值得注意的是，无论基类成员是合成的版本 (如 Quote 继承体系的例子) 还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问 (15.5 节) 并且不是一个被删除的函数

在我们的 Quote 继承体系中，所有类都使用合成的析构函数。其中，派生类隐式地使用而基类通过将其虚析构函数定义成 =default 而显式地使用。一如既往，合成的析构函数体是空的，其隐式的析构部分负责销毁类的成员 (13.1.3 节). 对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端

Quote 因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动 Quote 对象时实际使用的是合成的拷贝操作 (13.6.2 节). 如我们即将看到的那样，Quote 没有移动操作意味着它的派生类也没有

### 派生类中删除的拷贝控制与基类的关系

就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数 (13.1.6 节，第 450 页和 13.6.2 节，第 475 页). 此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数:

- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问 (15.5 节), 则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作
- 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分
- 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用 =default 请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的

举个例子，对于下面的基类 B 米说:

```c++
classB {
public:
	B();
	B(const B&) = delete;
// 其他成员，不含有移动构造函数
};

class D: public B {
// 没有声明任何构造函数
}
D d;// 正确：D 的合成默认构造画数使用 B 的默认构造函数
D d2(d);// 错误：D 的合成拷贝构造函数是被删除的
D d3(std::move(d));// 错误：隐式地使用 D 的被删除的拷贝构造函数
```

基类 B 含有一个可访问的默认构造函数和一个显式删除的拷贝构造函数。因为我们定义了拷贝构造函数，所以编译器将不会为 B 合成一个移动构造函数 (13.6.2 节，第 475 页)

因此，我们既不能移动也不能拷贝 B 的对象。如果 B 的派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。当然，在这一过程中派生类还必须考虑如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作

### 移动操作与继承

大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的 Quote 可以使用合成的版本，不过前提是 Quote 必须显式地定义这些成员。一旦 Quote 定义了自己的移动操作，那么它必须同时显式地定义拷贝操作 (13.6.2 节，第 476 页):

```c++
class Quote {
  public:
	Quote() =default;
// 对成员依次进行默认初始化
	Quote(const Quote&) =default; // 对成员依次拷贝
	Quote(Quote&&) =default; // 对成员依次拷贝
	Quote& operator=(const Quotes) =default; // 拷贝赋值
	Quote& operator=(Quote&&) =default; // 移动赋值
	Virtual ~Quote() =default;
// 其他成员与之前的版本一致
};
```

通过上面的定义，我们就能对 Quote 的对象逐成员地分别进行拷贝、移动、赋值和销毁操作了。而且除非 Quote 的派生类中含有排斥移动的成员，否则它将自动获得合成的移动操作

### 派生类的拷贝控制成员

派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值

和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。对象的成员是被隐式销毁的 (13.1.3 节，第 445 页): 类似的，派生类对象的基类部分也是自动销毁的

**当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象**

### 定义派生类的拷贝或移动构造函数

当为派生类定义拷贝或移动构造函数时 (13.1.1 节), 我们通常使用对应的基类构造函数初始化对象的基类部分:

```c++
class Base {/*...*/};
class D: public Base {
  public:
// 默认情况下，基类的默认构造函数初始化对象的基类部分
// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中
// 显式地调用该构造函数
	D(const D& d): Base(d) // 拷贝基类成员
		/*D 的成员的初始值 */{/*..*/}
	D(D&&d): Base(std::move(d)) // 移动基类成员
		/*D 的成员的初始值 */{/*..*/}
};
```

初始值 Base(d) 将一个 D 对象传递给基类构造函数。尽管从道理上来说，Base 可以包含一个参数类型为 D 的构造函数，但是在实际编程过程中通常不会这么做。相反，Base(d) 一般会匹配 Base 的拷贝构造函数. D 类型的对象 d 将被绑定到该构造函数的 Base & 形参上. Base 的拷贝构造函数负责将 d 的基类部分拷贝给要创建的对象。假如我们没有提供基类的初始值的话:

```c++
// D 的这个拷贝构造函数很可能是不正确的定义
// 基类部分被默认初始化，而非拷贝
D (const D& d)/* 成员初始值，但是没有提供基类初始值 */
	{/*..*/}
```

Base 的默认构造函数将被用来初始化 D 对象的基类部分。假定 D 的构造函数从 d 中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的 Base 成员被赋予了默认值，而 D 成员的值则是从其他对象拷贝得来的

在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想 拷贝 (或移动) 基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝 (或移动) 构造函数

### 派生类赋值运算符

与拷贝和移动构造函数一样，派生类的赋值运算符 (13.1.2 节) 也必须显式地为其基类部分赋值:

```c++
//Base::operator=(const Base&) 不会被自动调用
D& D::operator=(const D& rhs) {
	Base::operator=(rhs);// 为基类部分赋值
	// 按照过去的方式为派生类的成员赋值
	// 酌情处理自赋值及释放已有资源等情况
	return *this;
}
```

上面的运算符首先显式地调用基类赋值运算符，令其为派生类对象的基类部分赋值。基类的运算符 (应该可以) 正确地处理自赋值的情况，如果赋值命令是正确的，则基类运算符将释放掉其左侧运算对象的基类部分的旧值，然后利用 rhs 为其赋一个新值。随后，我们继续进行其他为派生类成员赋值的工作

值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用它们。例如，对于 Base::operator= 的调用语句将执行 Base 的拷贝赋值运算符，至于该运算符是由 Base 显式定义的还是由编译器合成的无关紧要

### 派生类析构函数

在析构函数体执行完成后，对象的成员会被隐式销毁 (13.1.3 节). 类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源:

```c++
class D: public Base {
  public:
//Base::~Base 被自动调用执行
	~D () {/* 该处由用户定义清除派生类成员的操作 */}
};
```

对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后

### 在构造函数和析构函数中调用虚函数

派生类对象的基类部分将首先被构建。当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成员的时候，该对象处于未完成的状态

为了能够正确地处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求；对于析构函数也是同样的道理。上述的绑定不但对直接调用虚函数有效，对间接调用也是有效的，这里的间接调用是指通过构造函数 (或析构函数) 调用另一个函数

为了理解上述行为，不妨考虑当基类构造函数调用虚函数的派生类版本时会发生什么情况。这个虚函数可能会访问派生类的成员，毕竟，如果它不需要访问派生类成员的话，则派生类直接使用基类的虚函数版本就可以了。然而，当执行基类构造函数时，它要用到的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃

**如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本**

### 继承的构造函数

在 C++11 新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为 “继承” 的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们

派生类继承基类构造函数的方式是提供一条注明了 (直接) 基类名的 using 声明语句。举个例子，我们可以重新定义 Bulk_quote 类, 令其继承 Disc_quote 类的构造函数:

```c++
class Bulk_quote: public Disc_quote {
  public:
	using Disc_quote::Disc_quote;// 继承 Disc_quote 的构造函数
	double net_price(std::size_t) const;
};
```

通常情况下，using 声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using 声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数

这些编译器生成的构造函数形如: `derived(parms):base(args){}`

其中，derived 是派生类的名字，base 是基类的名字，parms 是构造函数的形参列表，args 将派生类构造函数的形参传递给基类的构造函数。在我们的 Bulk_quote 类中，继承的构造函数等价于: `Bulk_quote(const std::strings book,double price,std::size_t qty,double disc):Disc_quote (book,price,qty,disc){}` 如果派生类含有自己的数据成员，则这些成员将被默认初始化

### 继承的构造函数的特点

和普通成员的 using 声明不一样，一个构造函数的 using 声明不会改变该构造函数的访问级别。例如，不管 using 声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数：受保护的构造函数和公有构造函数也是同样的规则

而且，一个 using 声明语句不能指定 explicit 或 constexpr. 如果基类的构造函数是 explicit (7.5.4 节) 或者 constexpr (7.5.6 节) 页), 则继承的构造函数也拥有相同的属性

当一个基类构造函数含有默认实参 (6.5.1 节) 时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参 (没有默认实参), 另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。

如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数:

1. 派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数
2. 默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数

## 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中

举个例子，假定我们想定义一个 vector, 令其保存用户准备购买的几种书籍。显然我们不应该用 vector 保存 Bulk_quote 对象。因为我们不能将 Quote 对象转换成 Bulk_quote (参见 15.2.3 节), 所以我们将无法把 Quote 对象放置在该 vector 中

其实，我们也不应该使用 vector 保存 Quote 对象。此时，虽然我们可以把 Bulk_quote 对象放置在容器中，但是这些对象再也不是 Bulk_quote 对象了:

```c++
vector<Quote>basket;
basket.push_back(Quote("0-201-82470-1",50));
// 正确：但是只能把对象的 Quote 部分拷贝给 basket
basket.push_back(Bulk_quote("0-201-54848-8",50,10,.25));
// 调用 Quote 定义的版本，打印 750, 即 15*$50
cout <<basket.back().net_price(15)<<endl;
```

basket 的元素是 Quote 对象，因此当我们向该 vector 中添加一个 Bulk_quote 对象时，它的派生类部分将被忽略掉 (参见 15.2.3 节，第 535 页)

**当派生类对象被赋值给基类对象时，其中的派生类部分将被 “切掉”, 因此容保器和存在继承关系的类型无法兼容**

在容器中放置 (智能) 指针而非对象
当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针 (更好的选择是智能指针). 和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型:

```c++
vector<shared_ptr<Quote>>basket;
basket.push_back(make_shared<Quote>("0-201-82470-1",50));
basket.push_back(make_shared<Bulk_quote>("0-201-54848-8",50,10,.25));
// 调用 Quote 定义的版本；打印 562.5, 即在 15*&50 中扣除掉折扣金额
cout<<basket.back()->net_price(15)<<endl;
```

因为 basket 存放着 shared_ptr, 所以我们必须解引用 basket.back() 的返回值以获得运行 netprice 的对象。我们通过在 net_price 的调用中使用 -> 以达到这个目的

如我们所知，实际调用的 net_price 版本依赖于指针所指对象的动态类型.
值得注意的是，我们将 basket 定义成 shared_prt<Quote>, 但是在第二个 push_back 中传入的是一个 Bulk_quote 对象的 shared_ptr. 正如我们可以将一个派生类的普通指针转换成基类指针一样 (15.2.2 节，第 530 页), 我们也能把一个派生类的智能指针转换成基类的智能指针。在此例中，make_shared<Bulk_quote> 返回一个 shared_ptr<Bulk_quote> 对象，当我们调用 push_back 时该对象被转换成 shared_ptr<Quote>. 因此尽管在形式上有所差别，但实际上 basket 的所有元素的类型都是相同的
