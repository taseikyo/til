# 14. Overloaded Operations and Conversions

## 14.1 基本概念

对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数： 

```c++
// 错误：不能为 int 重定义内置的运算符
int operator+(int, int);
```

这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。 

我们可以重载大多数（但不是全部）运算符。表 14.1 指明了哪些运算符可以被重载，哪些不行

我们只能重载已有的运算符，而无权发明新的运算符号。有四个符号（+、-、* 、&）既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符

对于一个重载的运算符来说，其优先级和结合律（4.1.2 节）与对应的内置运算符保持一致。不考虑运算对象类型的话，X==y+z；永远等价于 x==（y+z）

表 14.1：运算符

- 可以被重载的运算符

```c++
+ - * / % ^ & | ~ ! , = > < >> << == != ++ -- && || += -= /= %= ^= &= |= *= <<= >>= [] () -> ->* new  delete delete[]
```

- 不能被重载的运算符

```c++
:: .* . ?:
```

### 直接调用一个重载的运算符函数

通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式 “调用” 重载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参：

```c++
// 一个非成员运算符函数的等价调用
data1 + data2; // 普通的表达式
operator+(data1, data2); // 等价的函数调用
```

这两次调用是等价的，它们都调用了非成员函数 operator+，传入 data1 作为第一个实参、传入 data2 作为第二个实参。

我们像调用其他成员函数一样显式地调用成员运算符函数。具体做法是，首先指定运行函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数：

```c++
data1 += data2;// 基于 “调用” 的表达式
data1.operator+=(data2);// 对成员运算符函教的等价调用
```

这两条语句都调用了成员函数 operator+=，将 this 绑定到 data1 的地址、将 data2 作为实参传入了函数。

### 某些运算符不应该被重载

回忆之前介绍过的，某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符（4.3 节）和逗号运算符（4.10 节）的运算对象求值顺序规则无法保留下来。除此之外，&& 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。

因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。

还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++ 语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。

**通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符**

### 使用与内置类型一致的含义

重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回 bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用

### 选择作为成员或者非成员

当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员：另一些情况下，运算符作为普通函数比作为成员更好

下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：

- 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须是成员
- 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数

程序员希望能在含有混合类型的表达式中使用对称性运算符。例如，我们能求一个 int 和一个 double 的和，因为它们中的任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数

当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。例如：

```c++
string s = "world";
string t = s + "!"; // 正确：我们能把一个 const char * 加到一个 string 对象中
string u = "hi" + s; // 如果 + 是 string 的成员，则产生错误
```

如果 operator+ 是 string 类的成员，则上面的第一个加法等价于 s.operator+("！")。同样的，"hi"+s 等价于 "hi".operator+(s)。显然 "hi" 的类型是 const char* ，这是一种内置类型，根本就没有成员函数

因为 string 将 + 定义成了普通的非成员函数，所以 "hi"+s 等价于 operator+("hi", s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成 string

### 重载输出运算符 <<

通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用。之所以 ostream 是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个 ostream 对象

第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为（通常情况下）打印对象不会改变对象的内容。

为了与其他输出运算符保持一致，operator<< 一般要返回它的 ostream 形参

例如，我们按照如下形式编写 Sales_data 的输出运算符：

```c++
ostream& operator<<(ostream &os, const Sales_data &item) {
	os << item.isbn() << "" << item.units_sold << " "
	   << item.revenue << "" << item.avg_price();
	return os;
}
```

### 输出运算符尽量减少格式化操作

用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符打印了换行符，则用户就无法在对象的同一行内接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。

**输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符**

### 输入输出运算符必须是非成员函数

与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象：

```c++
Sales_data data;
data<<cout; // 如果 operator<< 是 Sales_data 的成员
```

假设输入输出运算符是某个类的成员，则它们也必须是 istream 或 ostream 的成员。然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员

因此，如果我们希望为类自定义 IO 运算符，则必须将其定义成非成员函数。当然，IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元（7.2.1 节）

### 重载输人运算符 >>

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中

例如，我们将按照如下形式编写 Sales_data 的输入运算符:

```c++
istream& operator>>(istream&is, Sales_data &item) {
	double price;// 不需要初始化，因为我们将先读入数据到 price, 之后才使用它
	is>>item.bookNo>>item.units_sold>>price;
	if (is)// 检查输入是否成功
		item.revenue=item.units_sold*price;
	else
		item=Sales_data ();// 输入失败：对象被赋予默认的状态
	return is;
}
```

if 语句检查读取操作是否成功，如果发生了 IO 错误，则运算符将给定的对象重置为空 Sales_data，这样可以确保对象处于正确的状态

**输入运算符必须处理输入可能失败的情况，而输出运算符不需要**

### 输入时的错误

在执行输入运算符时可能发生下列错误:

- 当流含有错误类型的数据时读取操作可能失败。例如在读取完 bookNo 后，输入运算符假定接下来读入的是两个数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都将失败
- 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败

在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据后赶在使用这些数据前一次性检查:

```c++
if (is)// 检查输入是否成功
	item.revenue=item.units_sold*price;
else
	item=Sales_data ();// 输入失败：对象被赋予默认的状态
```

如果在发生错误前对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。例如在这个输入运算符中，我们可能在成功读取新的 bookNo 后遇到错误，这意味着对象的 units_sold 和 revenue 成员并没有改变，因此有可能会将这两个数据与一条完全不匹配的 bookNo 组合在一起。通过将对象置为合法的状态，我们能（略微）保护使用者免于受到输入错误的影响

此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是一体的

** 当读取操作发生错误时，输入运算符应该负责从错误中恢复**

### 标示错误

一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查 bookNo 是否符合规范的格式。在这样的例子中，即使从技术上来看 IO 是成功的，输入运算符也应该设置流的条件状态以标示出失败信息（8.1.2 节）。通常情况下，输入运算符只设置 failbit。除此之外，设置 eofbit 表示文件耗尽，而设置 badbit 表示流被破坏。最好的方式是由 IO 标准库自己来标示这些错误

## 算术和关系运算符

通常情况下，我们把算术和关系运算符定义成**非成员函数**以允许对左侧或右侧的运算对象进行转换（14.1 节）。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用

算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符:

```c++
// 假设两个对象指向同一本书
sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) {
	Sales_data sum = lhs;// 把 lhs 的数据成员拷贝给 sum
	sum += rhs;// 将 rhs 加到 sum 中
	return sum;
}
```

**如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符**

### 相等运算符

通常情况下，C + 中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等

```c++
bool operator==(const Sales_data &lhs, const Sales_data &rhs) {
	return lhs.isbn() == rhs.isbn () &&
	       lhs.units_sold == rhs.units_sold &&
	       lhs.revenue == rhs.revenue;
}

bool operator!=(const Sales_data &lhs, const Sales_data &rhs) {
	return !(lhs == rhs);
}
```

就上面这些函数的定义本身而言，它们似乎比较简单，也没什么价值，对于我们来说重要的是从这些函数中体现出来的设计准则:

- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 operator== 而非一个普通的命名函数：因为用户肯定希望能使用 == 比较对象，所以提供了 == 就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了 == 运算符之后也更容易使用标准库容器和算法
- 如果类定义了 operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据
- 通常情况下，相等运算符应该具有传递性，换句话说，如果 a==b 和 b==c 都为真，则 a==c 也应该为真
- 如果类定义了 operator==，则这个类也应该定义 operator!=。对于用户来说，当他们能使用 == 时肯定也希望能使用！=，反之亦然
- 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符

### 关系运算符

定义了相等运算符的类也常常 (但不总是) 包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义 operator< 会比较有用

通常情况下关系运算符应该

1. 定义顺序关系，令其与关联容器中对关键字的要求一致 (11.2.2 节)
2. 如果类同时也含有 == 运算符的话，则定义一种关系令其与 == 保持一致。特别是，如果两个对象是 != 的，那么一个对象应该 < 另外一个

如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符。如果类同时还包含 =，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符

## 赋值运算符

在拷贝赋值和移动赋值运算符之外，标准库 vector 类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数（9.2.5 节），我们能以如下的形式使用该运算符:

```c++
vector<string> v;
v = {"a","an","the"};
```

同样，也可以把这个运算符添加到 strvec 类中 (13.5 节):

```c++
class StrVec{
public:
	strVec soperator=(std::initializer_list<std::string>);
	// 其他成员与 13.5 节一致
};
```

为了与内置类型的赋值运算符保持一致 (也与我们已经定义的拷贝赋值和移动赋值运算一致), 这个新的赋值运算符将返回其左侧运算对象的引用:

```c++
strVec &strVec::operator=(initializer_list<string>il) {
	//alloc ncopy 分配内存空间并从给定范围内拷贝元素
	auto data = alloc_n_copy(il.begin(), il.end());
	free();// 销级对象中的元素并释放内存空间
	elements = data.first;// 更新数据成员使其指向新空间
	first_free = cap = data.second;
	return*this;
}
```

和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，再创建一片新空间。不同之处是，这个运算符无须检查对象向自身的赋值，这是因为它的形参 initializer_list<string> (6.2.6 节，第 198 页) 确保 il 与 this 所指的不是同一个对象

**我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为 成员函数**

### 复合赋值运算符

复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。例如，下面是 Sales_data 类中复合赋值运算符的定义:

```c++
// 作为成员的二元运算符：左侧运算对象绑定到隐式的 this 指针
// 假定两个对象表示的是同一本书
Sales_data& Sales_data::operator+=(const Sales data &rhs) {
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this;
}
```

**赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做**

## 下标运算符

表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 operator[]

**下标运算符必须是成员函数**

为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值

举个例子，我们按照如下形式定义 StrVec (13.5 节) 的下标运算符:

```c++
class strVec {
  public: std::string& operator[](std::size_t n)
	{return elements[n];}
	const std::string& operator[](std::size_t n) const
	{return elements[n];}
// 其他成员与 13.5 (第 465 页) 一致
  private:
	std::string*elements;// 指向数组首元素的指针
};
```

上面这两个下标运算符的用法类似于 vector 或者数组中的下标。因为下标运算符返回的是元素的引用，所以当 strVec 是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值:

```c++
// 假设 svec 是一个 strvec 对象
const StrVec cvec = svec;// 把 svec 的元素拷贝到 cvec 中
// 如果 svec 中含有元素，对第一个元素运行 string 的 empty 函数
if(svec.size() && svec[0].empty()){
	svec[0]="zero";// 正确：下标运算符返回 string 的引用
	cvec[0]="zip";// 错误：对 cvec 取下标返回的是常量引用
}
```

## 递增和递减运算符

在迭代器类中通常会实现递增运算符 (++) 和递减运算符 (--), 这两种运算符使得类可以在元素的序列中前后移动。C++ 语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数

对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。接下来我们首先介绍前置版本，然后实现后置版本

### 定义前置递增/递减运算符

为了说明递增和递减运算符，我们不妨在 StrBlobPtr 类 (12.1.6 节) 中定义它们:

```c++
class StrBlobPtr {
  public:
	// 递增和递减运算符
	StrBlobPtr& operator++();// 前置运算符
	StrBlobPtr& operator--();
	// 其他成员和之前的版本一致
};
```

递增和递减运算符的工作机理非常相似：它们首先调用 check 函数检验 strBlobPtr 是否有效，如果是，接着检查给定的索引值是否有效。如果 check 函数没有抛出异常，则运算符返回对象的引用

```c++
// 前置版本：返回递增/递减对象的引用
StrBlobPtr&StrBlobPtr::operator++() {
// 如果 curr 已经指向了容器的尾后位置，则无法递增它
	check(curr, "increment past end of StrBlobPtr");
	++curr;
// 将 curr 在当前状态下向前移动一个元素
	return*this;
}

strBlobPtr&StrBlobPtr::operator--() {
// 如果 curr 是 0, 则继续递减它将产生一个无效下标
	--curr;// 将 curr 在当前状态下向后移动一个元素
	check(curr, "decrement past begin of StrBlobPtr");
	return*this;
}
```

### 区分前置和后置运算符

要想同时定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同

为了解决这个问题，后置版本接受一个额外的 (不被使用) int 类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算

```c++
class StrBlobPtr {
  public:
// 递增和递减运算符
	StrBlobPtr operator++(int);// 后置运算符
	StrBlobPtr operator--(int);
// 其他成员和之前的版本一致
};
```

对于后置版本来说，在递增对象之前需要首先记录对象的状态:

```c++
// 后置版本：递增 / 递减对象的值但是返回原值
StrBlobPtr StrBlobPtr::operator++(int) {
// 此处无须检查有效性，调用前置递增运算时才需要检查
	StrBlobPtr ret = *this; // 记录当前的值
	++*this;// 向前移动一个元素，前置 ++ 需要检查递增的有效性
	return ret;// 返回之前记录的状态 StrBlobPtr
}

StrBlobPtr::operator--(int) {
// 此处无须检查有效性，调用前置递减运算时才需要检查
	StrBlobPtr ret = *this; // 记录当前的值
	--*this;// 向后移动一个元素，前置 - 一需要检查递减的有效性
	return ret;// 返回之前记录的状态
}
```

由上可知，我们的后置运算符调用各自的前置版本来完成实际的工作。例如后置递增运算符执行 `++*this` 该表达式调用前置递增运算符，前置递增运算符首先检查递增操作是否安全，根据检查的结果抛出一个异常或者执行递增 curr 的操作。假定通过了检查，则后置函数返回事先存好的 ret 的副本。因此最终的效果是，对象本身向前移动了一个元素，而返回的结果仍然反映对象在未递增之前原始的值

**因为我们不会用到 int 形参，所以无须为其命名**

### 显式地调用后置运算符

如在第 491 页介绍的，可以显式地调用一个重载的运算符，其效果与在表达式中以运算符号的形式使用它完全一样。如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值:

```c++
StrBlobPtr p(a1);//p 指向 a1 中的 vector
p.operator++(0);// 调用后置版本的 operator++
p.operator++();// 调用前置版本的 operator++
```

尽管传入的值通常会被运算符函数忽略，但却必不可少，因为编译器只有通过它才能知道应该使用后置版本

## 成员访问运算符

在迭代器类及智能指针类 (12.1 节) 中常常用到解引用运算符 (* ) 和箭头运算符 (->)。

```c++
class StrBlobPtr {
  public:
  	std::string& operator*() const {
		auto p = check(curr, "dereference past end");
		return (*p)[curr];//(*p) 是对象所指的 vector
	}
	std::string* operator->() const {
		// 将实际工作委托给解引用运算符
		return &this->operator*();
		// 其他成员与之前的版本一致
	}
};
```

**箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此**

值得注意的是，我们将这两个运算符定义成了 const 成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变对象的状态。同时，它们的返回值分别是非常量 string 的引用或指针，因为一个 StrBlobPtr 只能绑定到非常量的 StrBlob 对象 (12.1.6 节)

```c++
StrBlob al={"hi","bye","now"];
StrBlobPtr p(al);//p 指向 al 中的 vector
*p = "okay";// 给 a1 的首元素赋值
cout<<p->size()<<endl;// 打印 4, 这是 a1 首元素的大小
cout <<(*p).size()<<endl;// 等价于 p->size ()
```

### 对箭头运算符返回值的限定

和大多数其他运算符一样 (尽管这么做不太好), 我们能令 operator* 完成任何我们指定的操作。换句话说，我们可以让 operator* 返回一个固定值 42, 或者打印对象的内容，或者其他。箭头运算符则不是这样，它永远不能丢掉成员访问这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变

对于形如 point->mem 的表达式来说，point 必须是指向类对象的指针或者是一个重载了 operator-> 的类的对象。根据 point 类型的不同，point->mem 分别等价于

```c++
(*point).mem;//point 是一个内置的指针类型
point.operator()->mem;//point 是类的一个对象
```

除此之外，代码都将发生错误. point->mem 的执行过程如下所示:

1. 如果 point 是指针，则我们应用内置的箭头运算符，表达式等价于 (*point).mem。首先解引用该指针，然后从所得的对象中获取指定的成员。如果 point 所指的类型没有名为 mem 的成员，程序会发生错误
2. 如果 point 是定义了 operator-> 的类的一个对象，则我们使用 point.operator->() 的结果来获取 mem。其中，如果该结果是一个指针，则执行第 1 步；如果该结果本身含有重载的 operator->(), 则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息

## 函数调用运算符

如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活

下面这个名为 absInt 的 struct 含有一个调用运算符，该运算符负责返回其参数的绝对值:

```c++
struct absInt {
	int operator()(int val) const {
		return val < 0 ? -val : val;
	}
};
```

我们使用调用运算符的方式是令一个 absInt 对象作用于一个实参列表，这一过程看起来非常像调用函数的过程:

```c++
int i = -42;
absInt absobj;// 含有函数调用运算符的对象
int ui = absobj(i);// 将 i 传递给 absObj.operator()
```

即使 absobj 只是一个对象而非函数，我们也能 “调用” 该对象。调用对象实际上是在运行重载的调用运算符。在此例中，该运算符接受一个 int 值并返回其绝对值

**函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别**

如果类定义了调用运算符，则该类的对象称作函数对象 (function object). 因为可以调用这种对象，所以我们说这些对象的 “行为像函数一样”

### 含有状态的函数对象类

和其他类一样，函数对象类除了 operator() 之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作

例如，我们定义一个打印 string 实参内容的类。默认情况下，我们的类会将内容写入到 cout 中，每个 string 之间以空格隔开。同时也允许类的用户提供其他可写入的流及其他分隔符。我们将该类定义如下:

```c++
class PrintString {
  public:
	PrintString(ostream &o = cout, char c = ' '): os(o), sep(c) {}
	void operator()(const string&s) const {os << s << sep;}
  private:
	ostream &os;// 用于写入的目的流
	char sep;// 用于将不同输出隔开的字符
};
```

我们的类有一个构造函数，它接受一个输出流的引用以及一个用于分隔的字符，这两个形参的默认实参 (6.5.1 节) 分别是 cout 和空格。之后的函数调用运算符使用这些成员协助其打印给定的 string

当定义 PrintString 的对象时，对于分隔符及输出流既可以使用默认值也可以提供我们自己的值:

```c++
Printstring printer;// 使用默认值，打印到 cout
printer(s);// 在 cout 中打印 s, 后面跟一个空格
PrintString errors(cerr, '\n');
errors (s);// 在 cerr 中打印 s, 后面跟一个换行符
```

函数对象常常作为泛型算法的实参。例如，可以使用标准库 for_each 算法 (10.3.2 节) 和我们自己的 PrintString 类来打印容器的内容: `for_each(vs.begin(), vs.end(), Printstring(cerr,'\n'));` for_each 的第三个实参是类型 Printstring 的一个临时对象，其中我们用 cerr 和换行符初始化了该对象。当程序调用 for_each 时，将会把 vs 中的每个元素依次打印到 cerr 中，元素之间以换行符分隔

### lambda 是函数对象

当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象 (10.3.3 节). 在 lambda 表达式产生的类中含有一个重载的函数调用运算符，例如，对于我们传递给 stable_sort 作为其最后一个实参的 lambda 表达式来说:

```c++
// 根据单词的长度对其进行排序，对于长度相同的单词按照字母表顺序排序
stable_sort(words.begin(), words.end(),
			[](const string &a, const string&b) {return a.size () < b.size ();});
```

其行为类似于下面这个类的一个未命名对象

```c++
class ShorterString {
  public:
	bool operator()(const string &s1, const string &s2) const
	{return s1.size() < s2.size ();}
};
```

如我们在 10.3.3 节所见，默认情况下 lambda 不能改变它捕获的变量。因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了

用这个类替代 lambda 表达式后，我们可以重写并重新调用 stable_sort: `stable_sort(words.begin(), words.end(), Shorterstring()); ` 第三个实参是新构建的 shorterString 对象，当 stable_sort 内部的代码每次比较两个 string 时就会 “调用” 这一对象，此时该对象将调用运算符的函数体，判断第一个 string 的大小小于第二个时返回 true

### 表示 lambda 及相应捕获行为的类

如我们所知，当一个 lambda 表达式通过引用捕获变量时，将由程序负责确保 lambda 执行时引用所引的对象确实存在 (10.3.3 节). 因此，编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员

相反，通过值捕获的变量被拷贝到 lambda 中 (10.3.3 节). 因此，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。举个例子，在 10.3.2 节中有一个 lambda, 它的作用是找到第一个长度不小于给定值的 string 对象:

```c++
// 获得第一个指向满足条件元素的选代器，该元素满足 size () is>=sz
auto wc = find_if(words.begin(),words.end(), [sz](const string sa) {return a.size()>=sz;});
```

该 lambda 表达式产生的类将形如:

```c++
class sizeComp {
	sizeComp(size_tn): sz(n) {} // 该形参对应捕获的变量
	// 该调用运算符的返回类型、形参和函数体都与 lambda 一致
	bool operator()(const string&s) const
	{return s.size () >= sz;}
  private:
	size_t sz;// 该数据成员对应通过值描获的变量
};
```

和我们的 shorterstring 类不同，上面这个类含有一个数据成员以及一个用于初始化该成员的构造函数。这个合成的类不含有默认构造函数，因此要想使用这个类必须提供一个实参:

```c++
// 获得第一个指向满足条件元素的选代器，该元素满足 size () is>=sz
auto wc = find_if(words.begin(),words.end(),SizeComp(sz));
```

lambda 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定 (13.1.6 节)

### 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus 类定义了一个函数调用运算符用于对一对运算对象执行 + 的操作；modulus 类定义了一个调用运算符执行二元的操作；equal_to 类执行 ==, 等等

这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，plus<string> 令 string 加法运算符作用于 string 对象；plus<int> 的运算对象是 int，以此类推:

```c++
plus<int>intAdd;// 可执行 int 加法的函数对
negate<int>intNegate;// 可对 int 值取反的函数对象
// 使用 intAdd::operator (int,int) 求 10 和 20 的和
int sum = intAdd(10,20);// 等价于 sum=30
sum = intNegate(intAdd(10,20));// 等价于 sum=30
// 使用 intNegate:::operator(int) 生成 - 10
// 然后将 - 10 作为 intAdd::operator(int,int) 的第二个参数
sum = intAdd(10,intNegate(10));//sum=0
```

表 14.2: 标准库函数对象（functional 头文件）

- 算术
	- plus<Type>
	- minus<Type>
	- multiplies<Type>
	- divides<Type>
	- modulus<Type>
	- negate<Type>
- 关系
	- equal_to<type>
	- not_equal_to<Type>
	- greater<Type>
	- greater_equal<Type>
	- less<Type>
	- less_equal<Type>
- 逻辑
	- logical_and<type>
	- logical_or<Type>
	- logical_not<Type>

### 在算法中使用标准库函数对象

在默认情况下排序算法使用 operator<将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个 greater 类型的对象

```c++
// 传入一个临时的函数对象用于执行两个 string 对象的 > 比较运算
sort(svec.begin(),svec.end(),greater<string>()); 
```

需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过比较两个无关指针将产生未定义的行为 (3.5.3 节，第 107 页), 然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector. 直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的:

```c++
vector<string*> nameTable;// 指针的 vector
// 错误:nameTable 中的指针彼此之间没有关系，所以 < 将产生未定义的行为
sort(nameTable.begin(),nameTable.end(),[](string*a,string*b){return a<b;});
// 正确：标准库规定指针的 less 是定义良好的
sort(nameTable.begin(),nameTable.end(),less<string*>());
```

关联容器使用 less<key_type> 对元素排序，因此我们可以定义一个指针的 set 或者在 map 中使用指针作为关键值而无须直接声明 less

### 可调用对象与 function

C++ 语言中有几种可调用的对象：函数、函数指针、lambda 表达式 (10.3.2 节)、bind 创建的对象 (10.3.4 节) 以及重载了函数调用运算符的类

和其他对象一样，可调用的对象也有类型。例如，每个 lambda 有它自己唯一的 (未命名) 类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等

然而，两个不同类型的可调用对象却可能共享同一种调用形式 (call signature). 调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如: `int (int,int)` 是一个函数类型，它接受两个 int、返回一个 int

### 不同类型可能具有相同的调用形式

对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象:

```c++
// 普通函数
int add(int i,int j) { return i+j;}
//lambda, 其产生一个未命名的函数对象类
auto mod=[](int i,int j){return i%j;};
// 函数对象类
struct divide {
	int operator ()( int denominator,int divisor){
		return denominator/divisor;
};
```

上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式: `int (int,int)` 我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个**函数表** (function table) 用于存储指向这些可调用对象的 “指针”. 当程序需要执行某个特定的操作时，从表中查找该调用的函数

在 C++ 语言中，函数表很容易通过 map 来实现。对于此例来说，我们使用一个表示运算符符号的 string 对象作为关键字；使用实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引 map, 然后调用找到的那个元素

假定我们的所有函数都相互独立，并且只处理关于 int 的二元运算，则 map 可以定义成如下的形式:

```c++
// 构建从运算符到函数指针的映射关系，其中函数接受两个 int、返回一个 
int map<string,int(*)(int,int)> binops;
```

我们可以按照下面的形式将 add 的指针添加到 binops 中:

```c++
// 正确:add 是一个指向正确类型函数的指针
binops.insert({"+", add});//{"+",add) 是一个 pair (ll.2.3 节，379 页)
```

但是我们不能将 mod 或者 divide 存入 binops:

```c++
binops.insert({"%", mod});// 错误:mod 不是一个函数指针
```

问题在于 mod 是个 lambda 表达式，而每个 lambda 有它自己的类类型，该类型与存储在 binops 中的值的类型不匹配

### 标准库 function 类型

我们可以使用名为 function 的新的标准库类型解决上述问题，function 定义在 functional 头文件中

表 14.3:function 的操作

- `function<T>f;` f 是一个用来存储可调用对象的空 function, 这些可调用对象的调用形式应该与函数类型 T 相同 (即 T 是 retType (args)
- `function<T> f(nullptr);` 显式地构造一个空 function
- `function<T> f(obj);` 在 f 中存储可调用对象 obj 的副本
- `f` 将 f 作为条件：当 f 含有一个可调用对象时为真；否则为假
- `f(args)` 调用 f 中的对象，参数是 args

定义为 function<T> 的成员的类型

- `result_type` 该 function 类型的可调用对象返回的类型
- `argument_type first_argument_type second_argument_type` 当 T 有一个或两个实参时定义的类型。如果 T 只有一个实参， 则 argument_type 是该类型的同义词；如果 T 有两个实参， 则 first_argument_type 和 second_argument_type 分别代表两个实参的类型

function 是一个模板，和我们使用过的其他模板一样，当创建一个具体的 function 类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 function 类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指定类型：`function<int(int,int)>` 在这里我们声明了一个 function 类型，它可以表示接受两个 int、返回一个 int 的可调用对象。

```c++
function<int(int,int)> f1 = add;// 画数指针
function<int(int,int)> f2 = divide();// 函数对象类的对象
function<int(int,int)> f3  =[](int i,int j){returni*j;};//lambda
cout<<f1(4,2)<<end1;// 打印 6
cout<<f2(4,2)<<end1;// 打印 2
cout<<f3(4,2)<<end1;// 打印 8
```

使用这个 function 类型我们可以重新定义 map:

```c++
// 列举了可调用对象与二元运算符对应关系的表格
// 所有可调用对象都必须接受两个 int、返回一个 int
// 其中的元素可以是函数指针、函数对象或者 lambda
map<string,function<int (int,int)>>binops;
```

我们能把所有可调用对象，包括函数指针、lambda 或者函数对象在内，都添加到这个 map 中:

```c++
map<string, function<int(int, int)>>binops = {
	{"+", add}, // 函数指针
	{"-", std::minus<int>()}, // 标准库函数对象
	{"/", divide()}, // 用户定义的函数对象
	{"*", [](int i, int j) {returni*j;}}, // 未命名的 lambda
	{"%", mod} // 命名了的 lambda 对象
};
```

如果我们索引 binops, 将得到 function 对象的引用。function 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象:

```c++
binops["+"](10,5);// 调用 add (10,5)
binops["-"](10,5);// 使用 minus<int> 对象的调用运算符 
binops["/"](10,5);// 使用 divide 对象的调用运算符 
binops["*"](10,5);// 调用 lambda 函数对象 
binops["%"](10,5);// 调用 lambda 函数对象
```

在第一个调用中，我们获得的元素存放着一个指向 add 函数的指针，因此调用 binops["+"](10,5) 实际上是使用该指针调用 add, 并传入 10 和 5. 在接下来的调用中，binops["-"] 返回一个存放着 std::minus<int>
类型对象的 function, 我们将执行该对象的调用运算符

### 重载的函数与 function

我们不能 (直接) 将重载函数的名字存入 function 类型的对象中:

```c++
int add(int i,int j){return i+j;}
Sales_data add(const Sales_data&, const Sales_data&);
map<string,function<int(int,int)>>binops;
binops.insert({"+", add});// 错误：哪个 add？
```

解决上述二义性问题的一条途径是存储函数指针 (6.7 节，第 221 页) 而非函数的名字:

```c++
int (*fp)(int,int)=add;// 指针所指的 add 是接受两个 int 的版本
binops.insert({"+",fp});// 正确:fp 指向一个正确的 add 版本
```

同样，我们也能使用 lambda 来消除二义性:

```c++
// 正确：使用 lambda 来指定我们希望使用的 add 版本
binops.insert({"+",[](int a,int b){return add(a,b);}};
```

lambda 内部的函数调用传入了两个 int, 因此该调用只能匹配接受两个 int 的 add 版本，而这也正是执行 lambda 时真正调用的函数

## 重载、类型转换与运算符

在 7.5.4 节 (第 263 页) 中我们看到由一个实参调用的非显式构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了类类型转换 (class-type conversions), 这样的转换有时也被称作用户定义的类型转换 (user-defined conversions)

### 类型转换运算符

类型转换运算符 (conversion operator) 是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示:

```c++
operator type() const;
```

其中 type 表示某种类型。类型转换运算符可以面向任意类型 (除了 void 之外) 进行定义，只要该类型能作为函数的返回类型 (6.1 节，第 184 页). 因此，我们不允许转换成数组或者函数类型，但允许转换成指针 (包括数组指针及函数指针) 或者引用类型

类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const 成员

举个例子，我们定义一个比较简单的类，令其表示 0 到 255 之间的一个整数:

```c++
class SmallInt {
  public:
	SmallInt(int i = 0): val(i) {
		if (i < 0 || i > 255)
			throw std::out_of_range("Bad SmallInt value");
	}
	operator int() const {return val;}
  private:
	std::size_t val;
};
```

我们的 SmallInt 类既定义了向类类型的转换，也定义了从类类型向其他类型的转换. 其中，构造函数将算术类型的值转换成 SmallInt 对象，而类型转换运算符将 SmallInt 对象转换成 int:

```c++
SmallInt si;
si=4;// 首先将 4 隐式地转换成 SmallInt, 然后调用 SmallInt::operator=
si+3;// 首先将 si 隐式地转换成 int, 然后执行整数的加法
```

尽管编译器一次只能执行一个用户定义的类型转换 (4.11.2 节，第 144 页), 但是隐式的用户定义类型转换可以置于一个标准 (内置) 类型转换之前或之后 (4.11.1 节，第 141 页), 并与其一起使用。因此，我们可以将任何算术类型传递给 SmallInt 的构造函数。类似的，我们也能使用类型转换运算符将一个 SmallInt 对象转换成 int, 然后再将所得的 int 转换成任何其他算术类型:

```c++
// 内置类型转换将 double 实参转换成 int
SmallInt si=3.14;// 调用 Sma1lInt (int) 构造函数
//SmallInt 的类型转换运算符将 si 转换成 int
si+3.14;// 内置类型转换将所得的 int 继续转换成 double
```

因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值:

```c++
class SmallInt;
operator int(SmallInt&);// 错误：不是成员函数
class SmallInt {
  public:
	int operator int() const;// 错误：指定了返回类型
	operator int(int = 0) const; // 错误：参数列表不为空
	operator int*() const {return 42;}// 错误：42 不是一个指针
};
```

### 提示：避免过度使用类型转换函数

和使用重载运算符的经验一样，明智地使用类型转换运算符也能极大地简化类设计者的工作，同时使得使用类更加容易。然而，如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性

例如，假设某个类表示 Date, 我们也许会为它添加一个从 Date 到 int 的转换。然而，类型转换函数的返回值应该是什么？一种可能的解释是，函数返回一个十进制数，依次表示年、月、日，例如，July 30,1989 可能转换为 int 值 19890730. 同时还存在另外一种合理的解释，即类型转换运算符返回的 int 表示的是从某个时间节点 (比如 January 1,1970) 开始经过的天数。显然这两种理解都合情合理，毕竟从形式上看它们产生的效果都是越靠后的日期对应的整数值越大，而且两种转换都有实际的用处

问题在于 Date 类型的对象和 int 类型的值之间不存在明确的一对一映射关系。因此在此例中，不定义该类型转换运算符也许会更好。作为替代的手段，类可以定义一个或多个普通的成员函数以从各种不同形式中提取所需的信息

### 类型转换运算符可能产生意外结果

在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感觉比较意外，而不是感觉受到了帮助。然而这条经验法则存在一种例外情况: 对于类来说，定义向 bool 的类型转换还是比较普遍的现象

在 C++ 标准的早期版本中，如果类想定义一个向 bool 的类型转换，则它常常遇到一个问题：因为 bool 是一种算术类型，所以类类型的对象转换成 bool 后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当 istream 含有向 bool 的类型转换时，下面的代码仍将编译通过:

```c++
int i = 42;
cin << i;// 如果向 bool 的类型转换不是显式的，则该代码在编译器看来将是合法的！
```

这段程序试图将输出运算符作用于输入流。因为 istream 本身并没有定义 <<, 所以本来代码应该产生错误。然而，该代码能使用 istream 的 bool 类型转换运算符将 cin 转换成 bool, 而这个 bool 值接着会被提升成 int 并用作内置的左移运算符的左侧运算对象. 这样一来，提升后的 bool 值 (1 或 0) 最终会被左移 42 个位置。这一结果显然与我们的预期大相径庭

### 显式的类型转换运算符

为了防止这样的异常情况发生，C++11 新标准引入了显式的类型转换运算符 (explicit conversion operator):

```c++
class Sma1lInt {
  public:
	// 编译器不会自动执行这一类型转换
	explicit operator int() const {return val;}
	// 其他成员与之前的版本一致
};
```

和显式的构造函数 (7.5.4 节) 一样，编译器 (通常) 也不会将一个显式的类型转换运算符用于隐式类型转换:

```c++
SmallInt si = 3;// 正确：Smal1Int 的构造函数不是显式的
si+3;// 错误：此处需要隐式的类型转换，但类的运算符是显式的
static_cast<int>(si)+3;// 正确：显式地请求类型转换
```

当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式的强制类型转换才可以

该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行:

- if、while 及 do 语句的条件部分
- for 语句头的条件表达式
- 逻辑非运算符 (!)、逻辑或运算符 (||)、逻辑与运算符 (&&) 的运算对象
- 条件运算符 (?:) 的条件表达式

转换为 bool 在标准库的早期版本中，IO 类型定义了向 void * 的转换规则，以求避免上面提到的问题。在 C++11 新标准下，IO 标准库通过定义一个向 bool 的显式类型转换实现同样的目的

无论我们什么时候在条件中使用流对象，都会使用为 IO 类型定义的 operator bool. 例如: `while (std::cin>>value)` while 语句的条件执行输入运算符，它负责将数据读入到 value 并返回 cin. 为了对条件求值，cin 被 istream operator bool 类型转换函数隐式地执行了转换。如果 cin 的条件状态是 good (8.1.2 节，第 280 页), 则该函数返回为真；否则该函数返回为假

**向 bool 的类型转换通常在条件部分，因此 operator bool 一半定义成 explicit**

### 避免有二义性的类型转换

如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式

在两种情况下可能产生多重转换路径：

1. 两个类提供相同的类型转换：例如，当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符时，我们就说它们提供了相同的类型转换
2. 类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则

通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换

### 实参匹配和相同的类型转换

在下面的例子中，我们定义了两种将 B 转换成 A 的方法：一种使用 B 的类型转换运算符、另一种使用 A 的以 B 为参数的构造函数:

```c++
// 最好不要在两个类之间构建相同的类型转换
struct B;
struct A {
	A() = default;
	A(const B&);// 把一个 B 转换成 A
// 其他数据成员
};
struct B {
	operator A() const;// 也是把一个 B 转接成 A
// 其他数据成员
};
A f(const A&);
B b;
A a = f(b);// 二义性错误：含义是 f(B::operator A())
// 还是 f (A::A(const B&))?
```

如果我们确实想执行上述的调用，就不得不显式地调用类型转换运算符或者转换构造函数:

```c++
A a1 = f(b.operator A());// 正确：使用 B 的类型转换运算符
A a2 = f(A(b));// 正确：使用 A 的构造函数
```

值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性

### 二义性与转换目标为内置类型的多重类型转换

另外如果类定义了一组类型转换，它们的转换源 (或者转换目标) 类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符

例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型；同时还包含两个类型转换运算符，它们的转换目标也恰好是两种不同的算术类型:

```c++
struct A {
	A (int = 0); // 最好不要创建两个转换源都是算术类型的类型转换
	A (double);
	operator int() const;// 最好不要创建两个转换对象都是算术类型的类型转换
	operator double() const;
// 其他成员
};
void f2(long double);
A a;
f2(a); // 二义性错误：含义是 f(A::operator int ())
// 还是 f (A::operator double())

long lg;
A a2(lg); // 二义性错误：含义是 A::A(int) 还是 A::A(double)？
```

在对 f2 的调用中，哪个类型转换都无法精确匹配 long double. 然而这两个类型转换都可以使用，只要后面再执行一次生成 long doub1e 的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性

调用 f2 及初始化 a2 的过程之所以会产生二义性，根本原因是它们所需的标准类型转换级别一致 (6.6.1 节，第 219 页). 当我们使用用户定义的类型转换时，如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程:

```c++
short s = 42;
// 把 short 提升成 int 优于把 short 转换成 double
A a3(s);
// 使用 A::A (int)
```

在此例中，把 short 提升成 int 的操作要优于把 short 转换成 doub1e 的操作，因此编译器将使用 A::A (int) 构造函数构造 a3, 其中实参是 s (提升后) 的值

当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个

### 提示：类型转换与运算符

要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。

以下的经验规则可能对你有所帮助：

- 不要令两个类执行相同的类型转换：如果 Foo 类有一个接受 Bar 类对象的构造函数，则不要在 Bar 类中再定义转换目标是 Foo 类的类型转换运算符
- 避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时，接下来
	- 不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符
	- 不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作

一言以蔽之：除了显式地向 bool 类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些 “显然正确” 的非显式构造函数

### 重载函数与转换构造函数

当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好

当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升：

```c++
struct C {
	C(int);
// 其他成员
};

struct D {
	D(int);
// 其他成员
};

void manip(const C&);
void manip(const D&);
manip(10);// 二义性错误：含义是 manip (C (10)) 还是 manip (D (10))
```

调用者可以显式地构造正确的类型从而消除二义性: `manip(C(10));// 正确：调用 manip (const C&)`

**如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参你的类型，则这通常意味着程序的设计存在不足**

### 重载函数与用户定义的类型转换

当调用重载函数时，如果两个 (或多个) 用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换

例如当我们调用 manip 时，即使其中一个类定义了需要对实参进行标准类型转换的构造函数，这次调用仍然会具有二义性:

```c++
struct E {
	E(double);
	// 其他成员
};

void manip2(const C&);
void manip2(const E&);
// 二义性错误：两个不同的用户定义的类型转换都能用在此处
manip2(10);// 含义是 manip2(C(10)) 还是 manip2(E(double(10)))
```

因为调用重载函数所请求的用户定义的类型转换不止一个且彼此不同，所以该调用具有二义性。即使其中一个调用需要额外的标准类型转换而另一个调用能精确匹配，编译器也会将该调用标示为错误

### 函数匹配与重载运算符

重载的运算符也是重载的函数。因此，通用的函数匹配规则 (6.4 节，第 208 页) 同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。不过当运算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调用函数时更大。如果 a 是一种类类型，则表达式 a sym b 可能是

```c++
a.operator sym(b);//a 有一个 operatorsym 成员函数
operator sym(a, b);//operator sym 是一个普通函数
```

和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数

当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内

当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，这是因为我们用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的。当我们通过类类型的对象 (或者该对象的指针及引用) 进行函数调用时，只考虑该类的成员函数。而当我们在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内.

**表达式中运算符的候选面数集既应该包括成员函数，也应该包括非成员函数**

举个例子，我们为 SmallInt 类定义一个加法运算符:

```c++
class SmallInt {
	friend SmallInt operator+(const SmallInt&, const SmallInt&);
  public:
	SmallInt(int = 0); // 转换源为 int 的类型转换
	operator int() const {return val;}// 转换目标为 int 的类型转换
  private:
	std::size_t val;
};
```

可以使用这个类将两个 SmallInt 对象相加，但如果我们试图执行混合模式的算术运算，就将遇到二义性的问题:

```c++
SmallInt s1,s2;
SmallInt s3=s1+s2;// 使用重载的 operator+
int i = s3+0;// 二义性错误
```

第二条加法语句具有二义性：因为我们可以把 0 转换成 SmallInt, 然后使用 SmallInt 的 +; 或者把 s3 转换成 int, 然后对于两个 int 执行内置的加法运算

**如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题**