# 16. Templates and Generic Programming

模板是 C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式. 当使用一个 vector 这样的泛型类型，或者 find 这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时

## 定义模板

假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第二个值。在实际中，我们的初次尝试可能定义多个重载函数:

// 如果两个值相等，返回 0, 如果 v1 小返回 - 1, 如果 v2 小返回 1

```c++
int compare (const string &v1, const string &v2) {
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

int compare (const double &v1, const double &v2) {
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}
```

### 函数模板

我们可以定义一个通用的函数模板 (function template), 而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本

```c++
template <typename T>
int compare(const T &v1, const T &v2) {
	if(v1 < v2) return -1;
	if(v2 < v1) return 1;
	return 0;
}
```

模板定义以关键字 template 开始，后跟一个模板参数列表 (template parameter list), 这是一个逗号分隔的一个或多个模板参数 (template parameter) 的列表，用小于号 (<) 和大于号 (>) 包围起来

**在模板定义中，模板参数列表不能为空**

模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化它们。在运行时，调用者提供实参来初始化形参

类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们 (隐式地或显式地) 指定**模板实参** (template argument), 将其绑定到模板参数上

### 实例化函数模板

当我们调用一个函数模板时，编译器 (通常) 用函数实参来为我们推断模板实参。即，当我们调用 compare 时，编译器使用实参的类型来确定绑定到模板参数 T 的类型

编译器用推断出的模板参数来为我们**实例化** (instantiate) 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新 “实例”. 例如，给定下面的调用:

```c++
// 实例化出 int compare(const ints,const int&)
cout<<compare(1, 0)<<endl; //T 为 int
// 实例化出 int compare(const vector<int>6,const vector<int>s)
vector<int>vec1{1, 2, 31}, vec2{4, 5, 6};
cout<<compare(vec1, vec2)<<end1; //T 为 vector<int>
```

对于第一个调用，编译器会编写并编译一个 compare 版本，其中 T 被替换为 int:

```c++
int compare(const int &v1, const int &v2) {
	if(v1 < v2) return -1;
	if(v2 < v1) return 1;
	return 0;
}
```

对于第二个调用，编译器会生成另一个 compare 版本，其中 T 被替换为 vector<int>. 这些编译器生成的版本通常被称为模板的**实例** (instantiation)

### 模板类型参数

我们的 compare 函数有一个模板**类型参数** (type parameter). 一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换:

```c++
// 正确：返回类型和参数类型相同
template <typename T>
T foo(T* p){
	T tmp = *p; //tmp 的类型将是指针 p 指向的类型
	//...
	return tmp;
}
```

类型参数前必须使用关键字 class 或 typename:

```c++
// 错误：U 之前必须加上 class 或 typename
template<typename T, U>
T calc(const T&, const U&);
```

在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字:

```c++
// 正确：在模板参数列表中，typename 和 class 没有什么不同
template<typename T,class U>
calc(const T&,const U&);
```

看起来用关键字 typename 指定模板类型参数比用 class 更为直观。毕竞，我们可以用内置 (非类) 类型作为模板类型实参。而且，typename 更清楚地指出随后的名字是一个类型名。但是，typename 是在模板已经广泛使用之后才引入 C++ 语言的，某些程序员仍然只用 class

### 非类型模板参数

除了定义类型参数，还可以在模板中定义**非类型参数** (nontype parameter). 一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替, 这些值必须是常量表达式 (2.4.4 节), 从而允许编译器在编译时实例化模板

例如，我们编写一个 compare 版本处理字符串字面常量。这种字面常量是 const char 的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用 (6.2.4 节). 第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度:

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]) {
	return strcmp (p1, p2);
}
```

当我们调用这个版本的 compare 时: `compare("hi","mom")` 编译器会使用字面常量的大小来代替 N 和 M, 从而实例化模板。记住，编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符 (2.1.3 节，第 36 页), 因此编译器会实例化出如下版本: `int compare (const char (&p1)[3],const char (&p2)[4])`

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或 (左值) 引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期 (第 12 章). 我们不能用一个普通 (非 static) 局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 nullptr 或一个值为 0 的常量表达式来实例化

在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小

**非类型模板参数的模板实参必须是常量表达式**

### inline 和 constexpr 的函数模板

函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样. inline 或 constexpr 说明符放在模板参数列表之后，返回类型之前:

```c++
// 正确:inline 说明符跟在模板参数列表之后
template <typename T>
inline T min(const T&,const T&);
// 错误:inline 说明符的位置不正确
inline template <typename T>
T min(const T&, const T&); 
```

### 编写类型无关的代码

我们最初的 compare  函数虽然简单，但它说明了编写泛型代码的两个重要原则:

- 模板中的函数参数是 const 的引用
- 函数体中的条件判断仅使用 < 比较运算

通过将函数参数设定为 const 的引用，我们保证了函数可以用于不能拷贝的类型。大多数类型，包括内置类型和我们已经用过的标准库类型 (除 unique_ptr 和 IO 类型之外), 都是允许拷贝的。但是，不允许拷贝的类类型也是存在的。通过将参数设定为 const 的引用，保证了这些类型可以用我们的 compare 函数来处理。而且，如果 compare 用于处理大对象，这种设计策略还能使函数运行得更快

你可能认为既使用 < 运算符又使用 > 运算符来进行比较操作会更为自然:

```c++
// 期望的比较操作
if (v1<v2) return-1;
if (v1>v2) return 1;
return 0;
```

但是，如果编写代码时只使用 < 运算符，我们就降低了 compare 函数对要处理的类型的要求。这些类型必须支持 <, 但不必同时支持 >

实际上，如果我们真的关心类型无关和可移植性，可能需要用 less (14.8.2 节) 来定义我们的函数:

```c++
// 即使用于指针也正确的 compare 版本；14.8.2 节
template <typename T>
int compare(const T &v1, const T &v2) {
	if (less<T>()(v1, v2)) return -1;
	if (less<T>()(v2, v1)) return 1;
	return 0;
}
```

原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的 (据查阅资料，less<T> 的默认实现用的就是 <, 所以这其实并未起到让这种比较有一个良好定义的作用一 — 译者注).

### 模板编译

当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用 (而不是定义) 模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义

### 关键概念：模板和头文件

模板包含两种名字:

- 那些不依赖于模板参数的名字
- 那些依赖于模板参数的名字

当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的

用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的

通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件

### 大多数编译错误在实例化期间报告

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的译错误。通常，编译器会在三个阶段报告错误:

1. 编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了
2. 编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的. 对
于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了
3. 模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译如何管理实例化，这类错误可能在链接时才报告

当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类有一些假设。例如，我们最初的 compare 函数中的代码就假定实参类型定义了 < 运算符

当编译器处理此模板时，它不能验证 if 语句中的条件是否合法。如果传递给 compare 的实参定义了 <运算符，则代码就是正确的，否则就是错误的。例如，

```c++
Sales_data data1,data2;
cout << compare(data1, data2)<<endl;// 错误：Sales_data 未定义 <
```

此调用实例化了 compare 的一个版本，将 T 替换为 Sales_data. if 条件试图对 Sales data 对象使用 < 运算符，但 Sales_data 并未定义此运算符。此实例化生成了一个无法编译通过的函数版本。但是，这样的错误直至编译器在类型 Sales_data 上实例化 compare 时才会被发现

**保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任**

### 类模板

**类模板** (class template) 是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息 —— 用来代替模板参数的模板实参列表

### 定义类模板

我们将实现 StrBlob (12.1.1 节) 的模板版本。我们将此模板命名为 Blob, 意指它不再针对 string. 类似 StrBlob, 我们的模板会提供对元素的共享 (且核查过的) 访问能力。与类不同，我们的模板可以用于更多类型的元素.
与标准库容器相同，当使用 Blob 时，用户需要指出元素类型

在类模板 (及其成员) 的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值:

```c++
template <typename T>
class Blob {
  public:
	typedef T value_type;
	typedef typename std::vector<T>::size_type size_type;
// 构造函数
	Blob(); Blob(std::initializer_list<T>il);
//Blob 中的元素数目
	size_type size() const {return data->size();}
	bool empty() const {return data->empty();}
	// 添加和删除元素
	void push_back(const T &t) {data->push_back(t);}
	// 移动版本，13.6.3 节
	void push_back(T&&t) {data->push_back(std::move(t));}
	void pop_back();
	// 元素访问
	T&back();
	T&operator [](size_type i);// 在 14.5 节中定义
  private:
	std::shared_ptr<std::vector<T>>data;
	// 若 data [i] 无效，则抛出 msg
	void check(size_type i, const std::string&msg) const;
};
```

我们的 Blob 模板有一个名为 T 的模板类型参数，用来表示 Blob 保存的元素的类型。例如，我们将元素访问操作的返回类型定义为 T&. 当用户实例化 Blob 时，T 就会被替换为特定的模板实参类型

### 实例化类模板

当使用一个类模板时，我们必须提供额外信息。我们现在知道这些额外信息是**显式模板实参** (explicit template argument) 列表，它们被绑定到模板参数. 编译器使用这些模板实参来实例化出特定的类

```c++
Blob<int> ia;// 空 Blob<int>
Blob<int> ia2 = {0,1,2,3,4};// 有 5 个元素的 Blob<int>
```

ia 和 ia2 使用相同的特定类型版本的 Blob (即 Blob<int>). 从这两个定义，编译器会实例化出一个与下面定义等价的类:

```c++
template<>
class Blob<int> {
	typedef typename std::vector<int>::size_type size_type;
	Blob();
	Blob(std::initializer_list<int>il);
//...
	ints operator [](size_type i);
  private:
  	std::shared_ptr<std::vector<int>>data;
	void check(size type i, const std::string&msg) const;
};
```

当编译器从我们的 Blob 模板实例化出一个类时，它会重写 Blob 模板，将模板参数 T 的每个实例替换为给定的模板实参，在本例中是 int

对我们指定的每一种元素类型，编译器都生成一个不同的类:

```c++
// 下面的定义实例化出两个不同的 Blob 类型
Blob<string> names;// 保存 string 的 Blob
Blob<double> prices;// 不同的元素类型
```

**一个类模板的每个实例都形成一个独立的类。类型 Blob<string> 与任何其他 Blob 类型都没有关联，也不会对任何其他 Blob 类型的成员有特殊访问权限**

### 在模板作用域中引用模板类型

为了阅读模板类代码，应该记住类模板的名字不是一个类型名 (3.3 节). 类模板用来实例化类型，而一个实例化的类型总是包含模板参数的

可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型 (或值) 的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的 data 成员使用了两个模板，vector 和 shared_ptr. 我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是 Blob 的模板参数。因此，data 的定义如下: `std::shared_ptr<std::vector<T>>data;` 它使用了 Blob 的类型参数来声明 data 是一个 shared_ptr 的实例，此 shared_ptr 指向一个保存类型为 T 的对象的 vector 实例。当我们实例化一个特定类型的 Blob, 例如 Blob<string> 时，data 会成为: `shared_ptr<vector<string>>` 如果我们实例化 Blob<int>, 则 data 会成为 shared_ptr<vector<int>>

### 类模板的成员函数

与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且**定义在类模板内的成员函数被隐式声明为内联函数**

类模板的成员函数本身是一个普通函数。类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表

与往常一样，当我们在类外定义一个成员时，必须说明成员属于哪个类。而且，从一个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与模板形参相同

```c++
template <typename T>
ret-type Blob<T>::member-name(parm-list)
```

### Blob 构造函数

与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始:

```c++
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) {}
```

这段代码在作用域 Blob<T> 中定义了名为 Blob 的成员函数。类似 StrBlob 的默认构造函数 (12.1.1 节，第 405 页), 此构造函数分配一个空 vector, 并将指向 vector 的指针保存在 data 中。如前所述，我们将类模板自己的类型参数作为 vector 的模板实参来分配 vector

类似的，接受一个 initializer_list 参数的构造函数将其类型参数 T 作为 initializer_list 参数的元素类型:

```c++
template <typename T>
Blob<T>::Blob(std::initializer_list<T>il):data(std::make_shared<std::vector<T>>(i1)){}

```

为了使用这个构造函数，我们必须传递给它一个 initializer_list, 其中的元素必须与 Blob 的元素类型兼容: `Blob<string> articles={"a","an","the"};`

这条语句中，构造函数的参数类型为 initializer_list<string>. 列表中的每个字符串字面常量隐式地转换为一个 string

### 类模板成员函数的实例化

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化

```c++
// 实例化 Blob<int> 和接受 initializer_list<int> 的构造函数
Blob<int>squares ={0,1,2,3,4,5,6,7,8,9};
// 实例化 Blob<int>::size() const
for (size_t i = 0; i != squares.size(); ++i)
	squares[i] = i * i; // 实例化 Blob<int>::operator [](size_t)
```

如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求 (9.2 节，第 294 页), 我们仍然能用该类型实例化类

**默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化**

### 在类代码内简化模板类名的使用

当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参:

```c++
// 若试图访问一个不存在的元素，BlobPtr 抛出一个异常
template <typename T>
class Blobptr {
  public:
	BlobPtr(): curr(0) {}
	BlobPtr(Blob<T>&a, size_t sz = 0): wptr(a.data), curr(sz) {}
	T&operator*() const {
		auto p = check(curr, "dereference past end");
		return (*p)[curr]; //(*p) 为本对象指向的 vector
	}
// 递增和递减
	BlobPtr&operator++();// 前置运算符
	BlobPtr&operator--();
  private:
// 若检查成功，check 返回一个指向 vector 的 shared_ptr
	std::shared_ptr<std::vector<T>> 
		check(std::size t, const std::strings) const;
// 保存一个 weak ptr, 表示底层 vector 可能被销毁
	std::weak_ptr<std::vector<T>>wptr;
	std::size_t curr;// 数组中的当前位置
};
```

细心的读者可能已经注意到，BlobPtr 的前置递增和递减成员返回 BlobPtr&, 而不是 BlobPtr<T>&. 当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。即，就好像我们这样编写代码一样:

```c++
BlobPtr<T>&operator++();
BlobPtr<T>&operator--();
```

### 在类模板外使用类模板名

当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域 (7.4 节):

```c++
// 后置：递增 / 递减对象但返回原值
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int) {
	// 此处无须检查；调用前置递增时会进行检查
	Blobptr ret = *this; // 保存当前值
	++*this;// 推进一个元素；前置 ++ 检查递增是否合法
	return ret;// 返回保存的状态
}
```

由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的 BlobPtr, 它所用类型与类实例化所用类型一致。在函数体内，我们已经进入类的作用域，因此在定义 ret 时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。因此，ret 的定义与如下代码等价:

`BlobPtr<T> ret = *this;`

*在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参*

### 类模板和友元

当一个类包含一个友元声明 (7.2.1 节) 时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例

### 一对一友好关系

类模板与另一个 (类或函数) 模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob 相等运算符（最初是在 14.3.1 节（第 498 页）练习中为 StrBlob 定义的）定义为友元

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：

```c++
// 前置声明，在 Blob 中声明友元所需要的
template <typename> class BlobPtr;
template <typename> class Blob;// 运算符 == 中的参数所需要的
template <typename T> bool operator==(const Blob<T>&,const Blob<T>&);
template <typename T>class Blob {
// 每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符
friend class BlobPtr<T>;
friend bool operator==<T> (const Blob<T>&,const Blob<T>&);
// 其他成员定义，与 12.1.1 (第 405 页) 相同
};
```

我们首先将 Blob、BlobPtr 和 operator== 声明为模板。这些声明是 operator== 函数的参数声明以及 Blob 中的友元声明所需要的

友元的声明用 Blob 的模板形参作为它们自己的模板实参。因此，友好关系被限定在用相同类型实例化的 Blob 与 BlobPtr 相等运算符之间：

```c++
Blob<char> ca;//BlobPtr<char> 和 operator==<char> 都是本对象的友元
Blob<int> ia;//Blobptr<int> 和 operator==<int> 都是本对象的友元
```

BlobPtr<char> 的成员可以访问 ca（或任何其他 Blob<char> 对象）的非 public 部分，但 ca 对 ia（或任何其他 Blob<int> 对象）或 Blob 的任何其他实例都没有特殊访问权限

### 通用和特定的模板友好关系

一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:

```c++
// 前置声明，在将模板的一个特定实例声明为友元时要用到
template <typename T>class Pal;
class C {//C 是一个普通的非模板类
	friend class Pal<C>;// 用类 C 实例化的 Pal 是 C 的一个友元
	//Pal2 的所有实例都是 C 的友元；这种情况无须前置声明
	template <typename T> friend class Pal2;
};

//C2 本身是一个类模板
template <typename T>class C2 {
	//C2 的每个实例将相同实例化的 Pa1 声明为友元
	friend class Pal<T>;//Pal 的模板声明必须在作用域之内
	//Pa12 的所有实例都是 C2 的每个实例的友元，不需要前置声明
	template <typename X> friend class Pal2;
	//Pa13 是一个非模板类，它是 C2 所有实例的友元
	friend class Pal3;// 不需要 Pal3 的前置声明
};
```

为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数

### 令模板自己的类型参数成为友元

在新标准中，我们可以将模板类型参数声明为友元:

```c++
template <typename Type> class Bar {
	friend Type;// 将访问权限授予用来实例化 Bar 的类型
	//... 
};
```

此处我们将用来实例化 Bar 的类型声明为友元。因此，对于某个类型名 Foo, Foo 将成为 Bar<Foo> 的友元，Sales_data 将成为 Bar<Sales_data> 的友元，依此类推

值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一个内置类型来实例化 Bar. 这种与内置类型的友好关系是允许的，以便我们能用内置类型来实例化 Bar 这样的类

### 模板类型别名

类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 typedef (参见 2.5.1 节，第 60 页) 来引用实例化的类: `typedef Blob<string> StrBlob;` 这条 typedef 语句允许我们运行在 12.1.1 节 (第 405 页) 中编写的代码，而使用的却是用 string 实例化的模板版本的 Blob. 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板。即，无法定义一个 typedef 引用 Blob<T>. 但是，新标准允许我们为类模板定义一个类型别名: 

```c++
template<typename T> using twin = pair<T,T>;
twin<string>authors;//authors 是一个 pair<string,string>
```

在这段代码中，我们将 twin 定义为成员类型相同的 pair 的别名。这样，twin 的用户只需指定一次类型。一个模板类型别名是一族类的别名:

```c++
twin<int> win_loss;//win_loss 是一个 pair<int,int>
twin<double> area;//area 是一个 pair<double,double>
```

就像使用类模板一样，当我们使用 twin 时，需要指出希望使用哪种特定类型的 twin. 当我们定义一个模板类型别名时，可以固定一个或多个模板参数:

```c++
template <typename T> using partNo = pair<T, unsigned>;
partNo<string>books;//books 是一个 pair<string,unsigned>
partNo<Vehicle>cars;//cars 是一个 pair<Vehicle,unsigned>
partNo<Student>kids;//kids 是一个 pair<student,unsigned>
```

这段代码中我们将 partNo 定义为一族类型的别名，这族类型是 second 成员为 unsigned 的 pair. partNo 的用户需要指出 pair 的 first 成员的类型，但不能指定 second 成员的类型

### 类模板的 static 成员

与任何其他类相同，类模板可以声明 static 成员 (参见 7.6 节，第 269 页):

```c++
template <typename T> class Foo {
public:
	static std::size_t count(){return ctr;}
	// 其他接口成员
private:
	static std::size_t ctr;
	// 其他实现成员
};
```

Foo 是一个类模板，它有一个名为 count 的 public static 成员函数和一个名为 ctr 的 private static 数据成员。每个 Foo 的实例都有其自己的 static 成员实例。即，对任意给定类型 X, 都有一个 Foo<X>::ctr 和一个 Foo<X>::count 成员。所有 Foo<x> 类型的对象共享相同的 ctr 对象和 count 函数

```c++
// 实例化 static 成员 Foo<string>::ctr 和 Foo<string>::count
Foo<string>fs;
// 所有三个对象共享相同的 Foo<int>::ctr 和 Foo<int>::count 成员
Foo<int>fi,fi2,fi3;
```

与任何其他 static 数据成员相同，模板类的每个 static 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 static 对象。因此，与定义模板的成员函数类似，我们将 static 数据成员也定义为模板: `template <typename T> size_t Foo<T>::ctr=0;// 定义并初始化 ctr` 与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员的类型和名字。与往常一样，成员名包括成员的类名，对于从模板生成的类来说，类名包括模板实参。因此，当使用一个特定的模板实参类型实例化 Foo 时，将会为该类类型实例化一个独立的 ctr, 并将其初始化为 0

与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 static 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问 static 成员，我们必须引用一个特定的实例:

```c++
Foo<int>fi;// 实例化 Foo<int> 类和 static 教据成员 ctr
auto ct = Foo<int>::count();// 实例化 Foo<int>::count
ct = fi.count();// 使用 Foo<int>::count
ct = Foo::count();// 错误：使用哪个模板实例的 count？
```

类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化

### 16.1.3 模板参数