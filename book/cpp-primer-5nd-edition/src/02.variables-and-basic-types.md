# 02. Variables and Basic Types

## 基本内置类型

### 带符号和无符号

与其他整型不同，字符型被分为了三种：char、signed char 和 unsigned char。特别需要注意的是：类型 char 和类型 signed char 并不一样。

尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

#### 建议：如何选择类型

和C语言一样，C++的设计准则之一也是尽可能地接近硬件。C++的算术类型必须满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员能够（也应该）对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的一些经验准则：

- 当明确知晓数值不可能为负时，选用无符号类型。
- 使用 int 执行整数运算。在实际应用中，short 常常显得太小而 long 一般和 int 有一样的尺寸。如果你的数值超过了 int 的表示范围，选用 long long。
- 在算术表达式中不要使用 char 或 bool，只有在存放字符或布尔值时才使用它们。因为类型 char 在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用 char 进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 signed char 或者 unsigned char。
- 执行浮点数运算选用 doub1e，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。

## 变量

### 初始化和赋值

当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialized）了。用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。

```c++
//正确：price 先被定义并赋值，随后被用于初始化 discount
double price = 109.99，discount = price * 0.16;
//正确：调用函数 applyDiscount，然后用函数的返回值初始化 salePrice
double salePrice = applyDiscount(price，discount);
```

在 C++ 语言中，初始化是一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人们特别容易把二者混为一谈。需要强调的是，这个概念至关重要，我们也将在后面不止一次提及这一点。

#### 注意：

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

### 列表初始化

C++ 语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为 units_sold 的 int 变量并初始化为 0，以下的 4 条语句都可以做到这一点：

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

作为 C++11 新标准的一部分，**用花括号来初始化变量**得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。出于 3.3.1 节将要介绍的原因，这种初始化的形式被称为列表初始化（list initialization）。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值
```

使用 long double 的值初始化 int 变量时可能丢失数据，所以编译器拒绝了 a 和 b 的初始化请求。其中，至少 ld 的小数部分会丢失掉，而且 int 也可能存不下 ld 的整数部分。

### 默认初始化

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。**定义于任何函数体之外的变量被初始化为 0**。然而如 6.1.1 节所示，一种例外情况是，**定义在函数体内部的内置类型变量将不被初始化（uninitialized）**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。

定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。

### 定义与声明

为了允许把程序拆分成多个逻辑部分来编写，C++ 语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

为了支持分离式编译，C++ 语言将声明和定义区分开来。

- 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
- 定义（definition）负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，**定义还申请存储空间，也可能会为变量赋一个初始值**。


如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量：

```c++
extern int i; // 声明 i 而非定义 i
int j; // 声明并定义 j
```

任何包含了显式初始化的声明即成为定义。我们能给由 extern 关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern 语句如果包含初始值就不再是声明，而变成定义了：

```c++
extern double pi = 3.1416; // 定义
```

在函数体内部，如果试图初始化一个由 extern 关键字标记的变量，将引发错误。

**变量能且只能被定义一次，但是可以被多次声明。**

## 复合类型

### 引用

引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。因为引用本身不是一个对象，所以不能定义引用的引用。

除了 2.4.1 节和 15.2.3 节将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起，相关原因将在 2.4.1 节详述：

```c++
int& refVal4 = 10; // 错误：引用类型的初始值必须是一个对象
double dval = 3.14; 
int& refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象
```

### 指针

指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。

指针与引用有很多不同点：

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

#### 指针值

指针的值（即地址）应属下列4种状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i = 42;
int *p; // p 是一个 int 型指针
int *&r = p; // r 是一个对指针 p 的引用
r = &i; // r 引用了一个指针，因此给 r 赋值 &i 就是令 p 指向 i
*r = 0; // 解引用 r 得到 i，也就是 p 指向的对象，将 i 的值改为 0
```

## const

C+程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。

### 对const的引用可能引用一个并非const的对象

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用 ri 绑定对象 i
const int &r2 = i; // r2 也绑定对象 i，但是不允许通过 r2 修改i的值
r1 = 0; // r1 并非常量，i 的值修改为 0
r2 = 0; // 错误：r2 是一个常量引用
```

r2 绑定（非常量）整数i是合法的行为。然而，不允许通过 r2 修改 i 的值。尽管如此，i 的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像 r1 一样绑定到i的其他引用来修改。

### constexpr和常量表达式

常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```c++
const int maxfiles = 20; // maxfiles 是常量表达式
const int limit = maxfiles+1; // limit 是常量表达式
int staff_size = 27; // staff_size 不是常量表达式
```

C++11 新标准规定，允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化：

```c++
constexpr int mf = 20;      // 20 是常量表达式
constexpr int limit = mf+1; // mf + 1 是常量表达式
constexpr int sz = size();  // 只有当 size() 是一个 constexpr 函数时
							// 才是一条正确的声明语句
```

## 处理类型

### 类型别名

传统方法使用 typedef，新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：

```c++
using SI = Sales_item; // SI 是 Sales_item 的同义词
```

这种方法用关键字 using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型 char* 的别名：

```c++
typedef char* pstring; 
const pstring cstr = 0; //cstr 是指向 char 的常量指针
const pstring *ps; // ps 是一个指针，它的对象是指向 char 的常量指针
```

上述两条声明语句的基本数据类型都是 const pstring，和过去一样，const 是对给定类型的修饰。pstring 实际上是指向 char 的指针，因此，const pstring 就是指向 char 的常量指针，而非指向常量字符的指针。

遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```c++
const char* cstr = 0; // 是对 const pstring cstr 的错误理解
```

再强调一遍：这种理解是错误的。声明语句中用到 pstring 时，其基本数据类型是指针。可是用 char* 重写了声明语句后，数据类型就变成了 char，* 成为了声明符的一部分。这样改写的结果是，const char 成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向 char 的常量指针，改写后的形式则声明了一个指向 const char 的指针。

### auto

编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11 新标准引入了 auto 类型说明符，用它就能让编译器替我们去分析表达式所属的类型。

### decltype

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11 新标准引入了第二种类型说明符 decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

```c++
decltype(f()) sum = x; // sum 的类型就是函数 f 的返回类型
```

编译器并不实际调用函数 f，而是使用当调用发生时f的返回值类型作为 sum 的类型。换句话说，编译器为 sum 指定的类型是什么呢？就是假如 f 被调用的话将会返回的那个类型。

```c++
const int ci = 0，&cj = ci;
decltype(ci) x = 0; // x 的类型是 const int 
decltype(cj) y = x; // y 的类型是 const int&，y 绑定到变量 x
decltype(cj) z; // 错误：z 是一个引用，必须初始化

//decltype的结果可以是引用类型
int i = 42，*p = &i，&r = i;
decltype(r + 0) b; // 正确：加法的结果是 int，因此b是一个（未初始化的）int 
decltype(*p) c; // 错误：c 是 int&，必须初始化
```

因为 r 是一个引用，因此 decltype(r) 的结果是引用类型。如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，如 r+0，显然这个表达式的结果将是一个具体值而非一个引用。

另一方面，如果表达式的内容是**解引用**操作，则 decltype 将得到**引用类型**。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(* p)的结果类型就是 int&，而非 int。

有一种情况需要特别注意：对于 decltype 所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型：**如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式**。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得到引用类型：

```c++
//decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d; // 错误：d 是 int&，必须初始化
decltype(i) e; // 正确：e 是一个（未初始化的）int
```

#### 注意

decltype((variable))（注意是双层括号）的结果永远是引用，而 decltype(variable) 结果只有当 variable 本身就是一个引用时才是引用。
